<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>DING Online</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#121a33; --panel2:#0f1730; --text:#e9eeff;
      --muted:#a7b0d6; --accent:#7c5cff; --danger:#ff5c7a; --good:#3ee28a;
      --stroke:rgba(255,255,255,.12);
      --shadow: 0 14px 40px rgba(0,0,0,.45);
      --radius: 16px;
      --cardW: 72px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(124,92,255,.25), transparent 60%),
                  radial-gradient(900px 700px at 80% 20%, rgba(62,226,138,.18), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height:1.25;
    }
    header{
      position:sticky; top:0; z-index:10;
      padding:14px 16px;
      background: linear-gradient(to bottom, rgba(11,16,32,.92), rgba(11,16,32,.65));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--stroke);
    }
    header .row{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
    .title{display:flex; gap:10px; align-items:center;}
    .pill{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      padding:8px 10px;
      border-radius: 999px;
      color: var(--muted);
      font-size: 13px;
      display:flex; gap:8px; align-items:center;
    }
    #statusBox{ display:none; }
    #trumpPill{
      font-weight:900;
      font-size:14px;
      letter-spacing:.2px;
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
    }
    .pill strong{color:var(--text); font-weight:700;}
    main{padding:16px; max-width:1100px; margin:0 auto;}
    body.notifier-on main{ padding-top:80px; }
    .grid{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
    }
    @media (max-width: 960px){
      .grid{grid-template-columns: 1fr;}
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:12px 14px;
      border-bottom:1px solid var(--stroke);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      background: rgba(255,255,255,.04);
    }
    .panel .bd{padding:14px;}
    .btn{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:700;
      transition:.12s transform, .12s background, .12s border;
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.10)}
    .btn:active{transform: translateY(0px)}
    .btn.primary{background: rgba(124,92,255,.22); border-color: rgba(124,92,255,.55)}
    .btn.primary:hover{background: rgba(124,92,255,.28)}
    .btn.danger{background: rgba(255,92,122,.18); border-color: rgba(255,92,122,.45)}
    .btn.good{background: rgba(62,226,138,.18); border-color: rgba(62,226,138,.45)}
    .btn:disabled{opacity:.45; cursor:not-allowed; transform:none}
    #startGameBtn{
      font-size:16px;
      font-weight:900;
      letter-spacing:.3px;
      padding:14px 16px;
      background: linear-gradient(135deg, rgba(124,92,255,.38), rgba(62,226,138,.18));
      border-color: rgba(124,92,255,.75);
      box-shadow: 0 14px 32px rgba(124,92,255,.2), 0 8px 20px rgba(0,0,0,.35);
    }
    #startGameBtn:hover{
      background: linear-gradient(135deg, rgba(124,92,255,.48), rgba(62,226,138,.26));
      transform: translateY(-2px);
    }
    @media (max-width: 640px){
      #startGameBtn{ width:100%; font-size:16px; }
    }
    .stack{display:flex; flex-direction:column; gap:10px;}
    .small{font-size:13px; color:var(--muted)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;}
    .scoreboard{
      display:flex; flex-direction:column; gap:8px;
    }
    .playerRow{
      display:flex; align-items:flex-start; justify-content:space-between; gap:16px;
      padding:12px 16px;
      border:1px solid var(--stroke);
      border-radius: 14px;
      background: rgba(0,0,0,.18);
      min-height:80px;
      flex-wrap:wrap;
    }
    .playerRow > div:first-child{
      flex: 1 1 220px;
      min-width: 0;
      max-width: 100%;
    }
    .playerRow .name{font-weight:800}
    .badge{
      padding:6px 8px; border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      font-size:12px; color:var(--muted);
      display:flex; gap:6px; align-items:center;
    }
    .badge strong{color:var(--text)}
    .tableArea{
      display:flex; flex-direction:column; gap:12px;
      padding-bottom:16px;
    }
    .trickArea{
      display:flex; gap:10px; flex-wrap:wrap; align-items:stretch;
    }
    .trickCard{
      min-width: 200px;
      flex: 1 1 200px;
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding:12px;
      background: rgba(0,0,0,.18);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .cardFace{
      width: var(--cardW);
      height: 96px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.18);
      background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
      display:flex; flex-direction:column; justify-content:space-between;
      padding:10px;
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
    }
    .cardFace .top{font-weight:900; font-size:14px}
    .cardFace .mid{font-size:20px; text-align:center}
    .cardFace .bot{font-weight:900; font-size:14px; text-align:right}
    .red{color:#ff7c95}
    .hand{
      display:flex; gap:10px; flex-wrap:wrap;
      align-items:flex-end;
    }
    .cardBtn{
      width: var(--cardW);
      height: 96px;
      border-radius: 14px;
      position: relative;
      border:1px solid rgba(255,255,255,.18);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
      padding:10px;
      cursor:pointer;
      display:flex; flex-direction:column; justify-content:space-between;
      transition: .12s transform, .12s border, .12s background;
      user-select:none;
    }
    .cardBtn:hover{transform: translateY(-2px); border-color: rgba(124,92,255,.7)}
    .cardBtn.selected{
      transform: translateY(-6px);
      border-color: rgba(62,226,138,.8);
      background: linear-gradient(180deg, rgba(62,226,138,.16), rgba(255,255,255,.05));
    }
    .cardBtn.disabled{
      opacity:.38; cursor:not-allowed; transform:none;
      border-color: rgba(255,255,255,.14);
    }
    /* gold outline for trump cards in-hand */
    .cardBtn.trump{ border-color: rgba(252,204,102,.55); box-shadow: 0 12px 28px rgba(252,204,102,.06); }

    /* Table trick slot layout: card on top, player name underneath */
    .trickSlot{ display:flex; flex-direction:column; align-items:center; gap:6px; min-width: var(--cardW); }
    /* Table card faces are slightly larger and styled differently than in-hand cards */
    .trickSlot .cardFace{ width: var(--cardW); height: calc(var(--cardW) * 1.45); border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.12); }
    .trickSlot .cardFace.enter{ animation: trickIn 420ms cubic-bezier(.2,.9,.2,1); }
    @keyframes trickIn{ 0%{ transform: translateY(-14px) scale(.98); opacity:0 } 60%{ transform: translateY(4px) scale(1.04); opacity:1 } 100%{ transform: translateY(0) scale(1) } }
    .cardBtn .top,.cardBtn .bot{font-weight:900; font-size:14px}
    .cardBtn .mid{font-size:20px; text-align:center}
    .row2{display:flex; gap:10px; flex-wrap:wrap;}
    .input{
      width:100%;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
    }
    .error{
      border:1px solid rgba(255,92,122,.55);
      background: rgba(255,92,122,.10);
      color: #ffd6de;
      padding:10px 12px;
      border-radius: 14px;
    }
    .lock{
      position:fixed; inset:0;
      background: rgba(6,8,16,.86);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:999;
      padding: 16px;
    }
    .lock .box{
      max-width: 520px; width:100%;
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .lock h2{margin:0 0 8px 0}
    .lock p{margin:0 0 12px 0; color:var(--muted)}
    .footerNote{margin-top:10px; color:var(--muted); font-size:12px}

    /* Card log (crude) */
    .cardLog{
      border:1px dashed var(--stroke);
      padding:8px;
      border-radius:12px;
      background: rgba(255,255,255,.02);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:12px;
      color:var(--muted);
    }
    .cardLog div{ margin:6px 0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .foldedBadge{ padding:4px 8px; border-radius:999px; background: rgba(255,255,255,.03); color:var(--muted); font-size:12px; border:1px dashed var(--stroke); display:inline-block; margin-left:6px; }

    /* More thoughtful folded pill used in table and scoreboard */
    .foldedPill{
      display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border: 1px solid rgba(255,255,255,.04); color:var(--muted); font-size:13px;
      box-shadow: none;
    }

    .collapseBtn{ padding:6px 8px; font-size:12px; display:none; }
    .panel.collapsed .bd{ display:none; }

    /* Header caret on the left */
    .panel .hd .caret{
      display:inline-block; width:14px; text-align:center; margin-right:8px; font-size:13px; opacity:.9; transition: transform .12s ease, opacity .12s ease;
      transform-origin: center;
    }
    .panel .hd .caret.collapsed{ transform: rotate(-90deg); opacity:.8; }
    .panel .hd:focus{ outline: 2px solid rgba(124,92,255,.12); outline-offset: 2px; border-radius: 12px; }

    /* Hide carets for non-collapsible sections */
    #tableCaret, #handCaret{ display:none; }

    /* hand hint spacing */
    #handHint{ margin-bottom:14px; }

    /* Mini card stack for won tricks */
    .wonTrick{ display:inline-block; position:relative; height:72px; margin-right:12px; }
    .miniCard{ width:40px; height:56px; border-radius:6px; border:1px solid rgba(255,255,255,.12); background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); display:flex; align-items:center; justify-content:center; font-size:13px; color:var(--muted); box-shadow: 0 6px 12px rgba(0,0,0,.25); }
    .miniCard.red{ color:#ff7c95 }
    .miniCard.winner{ border-color: rgba(124,92,255,.6); background: linear-gradient(180deg, rgba(124,92,255,.12), rgba(255,255,255,.02)); color:var(--text); }
    /* Styled pill for the trick winner summary */
    .pill.trick-winner{
      padding:10px 14px;
      border-radius:12px;
      background: linear-gradient(90deg, rgba(124,92,255,.14), rgba(62,226,138,.06));
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: 0 8px 30px rgba(124,92,255,.06), inset 0 1px 0 rgba(255,255,255,.02);
      color: var(--text);
      gap:12px;
      align-items:center;
    }
    .pill.trick-winner .miniCard{ width:48px; height:64px; font-size:14px; border-radius:8px; }
    .pill.trick-winner .label{ color:var(--muted); font-size:12px; }
    .pill.trick-winner strong{ font-size:15px; }

    /* Mini trick counter in scoreboard */
    .trickVisualizer{ display:flex; gap:10px; align-items:center; }
    .trickChipsRow{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    /* treat each chip like a tiny card */
    .trickChip{
      width:38px; height:52px; border-radius:8px;
      border:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.005));
      box-shadow: 0 8px 18px rgba(0,0,0,.32);
      display:flex; align-items:center; justify-content:center;
      transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
      overflow:hidden;
    }
    .trickChip.empty{ opacity:.28; background: linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,.005)); }
    /* gold-filled mini-card for won tricks */
    .trickChip.filled{
      background: linear-gradient(180deg, #fbf6e3, #f7e9b8);
      border:1px solid rgba(255,230,150,.25);
      box-shadow: 0 10px 28px rgba(245,200,80,.12), inset 0 1px 0 rgba(255,255,255,.6);
    }
    .trickChip.filled .chipInner{
      width:86%; height:78%; border-radius:6px; display:flex; align-items:center; justify-content:center; font-size:16px; color:#6b4300;
      background: linear-gradient(180deg, rgba(255,235,160,.98), rgba(255,205,90,.98));
      box-shadow: 0 6px 14px rgba(204,150,26,.12) inset;
    }
    /* subtle lateral shake for the most-recent chip (light, tasteful) */
    .trickChip.recent{ transform: translateY(0); box-shadow: 0 20px 40px rgba(245,190,40,.14); animation: subtleShake 900ms ease-in-out infinite; }
    @keyframes subtleShake{
      0% { transform: translate3d(0,0,0) rotate(0deg); }
      20% { transform: translate3d(-2px,0,0) rotate(-0.6deg); }
      40% { transform: translate3d(1.5px,0,0) rotate(0.4deg); }
      60% { transform: translate3d(-1px,0,0) rotate(-0.3deg); }
      80% { transform: translate3d(0.6px,0,0) rotate(0.2deg); }
      100% { transform: translate3d(0,0,0) rotate(0deg); }
    }
    .scoreTrophy{ display:flex; gap:8px; align-items:center; background: linear-gradient(90deg, rgba(255,245,210,.16), rgba(255,255,255,0)); padding:6px 10px; border-radius:12px; border:1px solid rgba(255,230,140,.08); color: #8a5b0b; font-weight:800; font-size:13px; }

    /* total score pill: bold gold display that stands out */
    .totalScore{
      display:flex; align-items:center; justify-content:center; min-width:80px; padding:8px 10px; gap:8px;
      background: linear-gradient(180deg, #fff7e6, #ffe59e);
      border: 1px solid rgba(255,210,110,.25);
      border-radius: 14px; color: #6b3f00; font-weight:900; box-shadow: 0 18px 44px rgba(245,190,40,.12), inset 0 1px 0 rgba(255,255,255,.6);
      transition: transform .18s ease, box-shadow .18s ease;
      font-size:13px;
      text-align:center;
      flex: 0 0 auto;
      margin-left: auto;
    }
    .totalScore .scoreValue{ font-size:16px; margin-left:4px; color:#4a2d00; }
    .totalScore.pulse{ animation: scorePulse 2400ms ease-in-out infinite; }
    @keyframes scorePulse{
      0% { box-shadow: 0 14px 36px rgba(245,190,40,.08); transform: translateY(0); }
      50% { box-shadow: 0 26px 60px rgba(245,170,30,.14); transform: translateY(-2px); }
      100% { box-shadow: 0 14px 36px rgba(245,190,40,.08); transform: translateY(0); }
    }
    /* deck visualizer removed */
    /* scoreboard highlights */
    .playerRow.activeTurn{ border-color: rgba(124,92,255,.45); box-shadow: 0 12px 30px rgba(124,92,255,.06); }
    .dealerBadge{ padding:4px 8px; border-radius:8px; background: rgba(255,215,130,.06); color:#ffdca8; font-size:12px; border:1px solid rgba(255,215,130,.06); margin-left:6px; }
    .turnDot{ color: var(--good); font-size:14px; margin-left:6px; font-weight:900; }
    /* raise the top-most mini-card more so it doesn't cover lower card text */
    .wonTrick .miniCard:last-child{ transform: translateY(-28px); z-index:2; box-shadow: 0 14px 24px rgba(0,0,0,.4); }
    .wonTricksRow{ display:flex; align-items:flex-start; gap:12px; margin-top:8px; }

    /* Deal & swap animations üîß */
    .fly-in{
      animation: flyIn .45s cubic-bezier(.2,.9,.2,1) both;
    }
    .fly-out{
      animation: flyOut .35s cubic-bezier(.4,.0,.2,1) both;
      transform-origin: center;
    }
    @keyframes flyIn{
      from { transform: translateY(-24px) scale(.96); opacity: 0; filter: blur(1px); }
      to   { transform: translateY(0) scale(1);    opacity: 1; filter: none; }
    }
    @keyframes flyOut{
      from { transform: translateY(0) scale(1); opacity: 1; }
      to   { transform: translateY(-28px) scale(.7) rotate(-8deg); opacity: 0; filter: blur(2px); }
    }
    /* play animation clone (card flying to table) */
    .playClone{
      position:fixed; z-index:9999; pointer-events:none; border-radius:14px; box-shadow: 0 18px 40px rgba(0,0,0,.45);
      transition: transform .45s cubic-bezier(.2,.9,.2,1), opacity .35s ease;
      transform-origin: center center;
    }

    /* incoming-card sparkle */
    .fly-in::after{
      content: ''; position: absolute; left: 50%; top: 20%; transform: translateX(-50%) translateY(-10%);
      width: 10px; height: 10px; border-radius:50%;
      background: radial-gradient(circle at center, rgba(255,255,255,.95) 0%, rgba(255,255,255,.6) 30%, rgba(255,255,255,0) 60%);
      opacity: 0; pointer-events:none; mix-blend-mode: screen;
      animation: sparkle 700ms cubic-bezier(.2,.9,.2,1) forwards;
    }
    @keyframes sparkle{
      0% { transform: translateX(-50%) translateY(-10%) scale(.4); opacity: 0; }
      40% { transform: translateX(-50%) translateY(-20%) scale(1.4); opacity: .98; }
      100% { transform: translateX(-50%) translateY(-40%) scale(1.8); opacity: 0; }
    }

    /* pop animation for trick-winner pill */
    .pill.trick-winner.pop{ animation: popIn 420ms cubic-bezier(.2,.85,.25,1); }
    @keyframes popIn{
      0%{ transform: scale(.88); opacity:0; }
      40%{ transform: scale(1.06); opacity:1; }
      70%{ transform: scale(.98); }
      100%{ transform: scale(1); }
    }
    /* Responsive tweaks for iPhone / narrow screens */
    @media (max-width: 640px){
      :root{ --cardW: 60px; }
      header{ padding:10px 12px; }
      main{ padding:12px; }
      .panel .hd{ padding:10px 12px; }
      .panel .bd{ padding:12px; }
      .tableArea{ gap:10px; }
      .trickArea{ gap:8px; }
      .hand{ gap:8px; }
      .row2{ gap:8px; }
      .scoreboard{ gap:6px; }
      .playerRow{
        padding:10px 12px;
        min-height:64px;
        gap:12px;
        align-items:center;
      }
      .badge{ padding:4px 6px; font-size:11px; }
      .trickChip{ width:32px; height:44px; border-radius:7px; }
      .trickChip.filled .chipInner{ font-size:13px; }
      .totalScore{
        min-width:68px;
        padding:6px 8px;
        font-size:12px;
        border-radius:12px;
      }
      .totalScore .scoreValue{ font-size:15px; margin-left:4px; }
      .totalScore .scoreLabel{ font-size:11px; }
    }
    /* Responsive tweaks for narrow/phone screens */
    @media (max-width: 520px){
      :root{ --cardW: 56px; }
      header{ padding:10px 12px }
      .title div{ font-size:14px }
      .pill{ padding:6px 8px; font-size:12px }
      .cardBtn{ width: var(--cardW); height: calc(var(--cardW) * 1.3); }
      .cardFace{ width: var(--cardW); height: calc(var(--cardW) * 1.35); }
      .trickSlot{ min-width: var(--cardW); }
      .trickChip{ width:28px; height:40px; border-radius:6px }
      .trickChip.filled .chipInner{ font-size:12px }
      .pill.trick-winner .miniCard{ width:40px; height:52px }
      .totalScore{ min-width:76px; padding:8px 10px; font-size:13px }
      .wonTrick .miniCard:last-child{ transform: translateY(-20px); }
    }
    @media (max-width: 360px){
      :root{ --cardW: 48px; }
      .trickChip{ width:24px; height:36px }
      .pill.trick-winner{ padding:8px 10px }
      .pill.trick-winner .miniCard{ width:34px; height:44px }
      .title div{ font-size:13px }
      .scoreboard .playerRow{ padding:10px }
      .hand{ gap:8px }
    }

    /* Auto-pass small ring */
    .autoPassRing{
      width:26px; height:26px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.06); color:var(--muted);
      box-shadow: 0 6px 12px rgba(0,0,0,.3);
    }
    /* notifier styles */
    #notifier{ border:1px solid rgba(255,255,255,.08); background: linear-gradient(180deg, rgba(12,18,36,.92), rgba(12,18,36,.78)); }
    #notifier{
      position: fixed;
      left: 50%;
      top: 100px;
      transform: translateX(-50%);
      width: min(1100px, calc(100% - 24px));
      margin: 0;
      z-index: 20;
    }
    #notifierIcon{ font-size:20px; }
    #notifierTitle{ font-size:15px }
    /* notifier action visually present but non-interactive; actions belong in main UI */
    #notifierAction{ background: rgba(124,92,255,.14); border:1px solid rgba(124,92,255,.28); color:var(--text); display:none !important; pointer-events:none; }
    @media (max-width:720px){ #notifier{ top:100px; width: calc(100% - 24px); } #notifierAction{ display:none } }
    @media (max-width:640px){ body.notifier-on main{ padding-top:88px; } .tableArea{ padding-bottom:24px; } }
    /* lobby settings */
    .settingsCard{
      padding:12px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(124,92,255,.10), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
    }
    .settingsHeader{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:6px 6px 10px 6px;
      cursor:pointer;
      user-select:none;
    }
    .settingsCard.collapsed .settingsBody{ display:none; }
    .settingRow{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      align-items:center;
      padding:10px 8px;
      border-radius:12px;
      background: rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.04);
    }
    .settingRow + .settingRow{ margin-top:10px; }
    .settingLabel{ font-weight:800; }
    .settingMeta{ color:var(--muted); font-size:12px; margin-top:4px; }
    .settingValue{
      font-weight:900; font-size:14px; padding:6px 10px;
      border-radius:10px; background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      min-width:56px; text-align:center;
    }
    .settingControls{ display:flex; align-items:center; gap:10px; }
    .settingRow input[type="range"]{ width:160px; max-width:60vw; accent-color: var(--accent); }
    .settingToggle{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10);
      font-weight:800; font-size:12px; color:var(--muted);
    }
    .settingToggle input{ width:18px; height:18px; }
    /* mode + multiplayer */
    .modeCard{
      padding:12px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(62,226,138,.10), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
    }
    .modeRow{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .modeBtn{
      padding:8px 12px; border-radius:12px; font-weight:800;
      border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.06);
      cursor:pointer; color:var(--muted);
    }
    .modeBtn.active{
      color:var(--text);
      border-color: rgba(124,92,255,.45);
      background: rgba(124,92,255,.22);
    }
    .mpCard{
      padding:12px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.01));
      box-shadow: var(--shadow);
    }
    .mpRow{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .mpCode{ min-width:120px; text-transform:uppercase; letter-spacing:.8px; }
    .mpStatus{ font-size:12px; color:var(--muted); }
    .logCard{
      border:1px solid var(--stroke);
      border-radius:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .logHeader{
      display:flex; align-items:center; gap:8px;
      padding:10px 12px;
      cursor:pointer;
      border-bottom:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
    }
    .logCaret{
      display:inline-block; width:14px; text-align:center;
      transition: transform .12s ease;
    }
    .logCard.collapsed .logCaret{ transform: rotate(-90deg); }
    .logBody{ padding:12px; display:block; }
    .logCard.collapsed .logBody{ display:none; }
    .logList{
      max-height:240px;
      overflow-y:auto;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding-right:4px;
    }
    .handLog{
      border:1px solid var(--stroke);
      border-radius:12px;
      background: rgba(0,0,0,.18);
      padding:6px 10px;
    }
    .handLog summary{
      list-style:none;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .handLog summary::-webkit-details-marker{ display:none; }
    .handTitle{ font-weight:800; font-size:13px; }
    .handScores{ font-size:12px; color:var(--muted); }
    .handPlays{ margin-top:8px; display:flex; flex-direction:column; gap:6px; }
    .trickLog{
      border-top:1px dashed var(--stroke);
      padding-top:6px;
    }
    .trickLog:first-child{ border-top:none; padding-top:0; }
    .playLine{
      display:flex; align-items:center; justify-content:space-between;
      gap:8px;
      font-size:12px;
      color:var(--muted);
    }
    .lobbyList{ display:flex; flex-direction:column; gap:6px; }
    .lobbyPlayer{
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:12px;
      background: rgba(0,0,0,.18);
      font-size:13px;
    }
    /* winner banner */
    #winnerBanner{
      border:1px solid rgba(255,230,140,.12);
      background: linear-gradient(120deg, rgba(255,235,160,.12), rgba(124,92,255,.08));
      box-shadow: 0 18px 44px rgba(245,190,40,.12);
    }
    #winnerIcon{
      width:44px; height:44px; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,235,160,.25);
      border:1px solid rgba(255,230,140,.25);
      font-size:20px;
    }
    .dingBadge{
      padding:4px 8px; border-radius:10px;
      border:1px solid rgba(255,92,122,.35);
      background: rgba(255,92,122,.12);
      font-size:12px; color:#ffd6de; display:inline-flex; gap:6px; align-items:center;
    }
  </style>
</head>
<body>
<header>
  <div class="row">
    <div class="title">
      <div style="width:34px;height:34px;border-radius:12px;background:rgba(124,92,255,.25);border:1px solid rgba(124,92,255,.5);display:flex;align-items:center;justify-content:center;font-weight:900;">‚ô§</div>
      <div>
        <div style="font-weight:900;font-size:16px;">DING Online</div>
        <div class="small">Good luck!</div>
      </div>
    </div>
    <div class="row2">
      <div class="pill"><span>Phase:</span> <strong id="phasePill">LOBBY</strong></div>
      <div class="pill"><span>Trump:</span> <strong id="trumpPill">‚Äî</strong></div>
      <div class="pill"><span>Lead suit:</span> <strong id="leadPill">‚Äî</strong></div>
    </div>
  </div>
  <div id="headerGreeting" class="small" style="margin-top:6px;display:none;"></div>
</header>

<!-- Unified notifier: shows phase, actor, and concise instructions -->
<div id="notifier" class="panel" style="margin:12px auto;max-width:1100px;border-radius:12px;display:none;">
  <div class="bd" style="display:flex;align-items:center;gap:12px;padding:10px 14px;">
    <div id="notifierIcon" style="width:44px;height:44px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.03);font-size:20px;">üîî</div>
    <div style="flex:1;min-width:0;">
      <div id="notifierTitle" style="font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">Status</div>
      <div id="notifierDetail" class="small" style="opacity:.9;">‚Äî</div>
    </div>
    <div id="notifierMeta" style="display:flex;align-items:center;gap:8px;">
      <div id="notifierPlayer" class="pill" style="padding:6px 10px;border-radius:10px;">‚Äî</div>
      <div id="notifierAction" class="btn" style="padding:8px 10px;">‚Äî</div>
    </div>
  </div>
</div>
<!-- Winner banner: shows when a player hits 0 -->
<div id="winnerBanner" class="panel" style="margin:12px auto;max-width:1100px;border-radius:12px;display:none;">
  <div class="bd" style="display:flex;align-items:center;gap:12px;padding:12px 14px;">
    <div id="winnerIcon">üèÜ</div>
    <div style="flex:1;min-width:0;">
      <div id="winnerTitle" style="font-weight:900;">Winner</div>
      <div id="winnerDetail" class="small" style="opacity:.9;">‚Äî</div>
    </div>
  </div>
</div>

<main>
  <div class="grid">
    <section id="gamePanel" class="panel">
      <div id="gameHeader" class="hd">
        <div style="font-weight:900;"><span class="caret" id="gameCaret">‚ñæ</span>Game Lobby</div>
        <div class="row2">
          <div id="gameSummary" class="small mono" style="margin-right:8px;">‚Äî</div>
          <button class="btn collapseBtn" id="collapseGameBtn">‚ñæ</button>
          <button class="btn danger" id="resetBtn">Reset</button>
        </div>
      </div>
        <div class="bd stack">
          <div id="lobbyArea" class="stack">
            <div id="lobbyHotseatIntro" class="small">Enter 2-6 player names (one per line). Then start.</div>
            <textarea id="namesInput" class="input" rows="6" placeholder="Player 1&#10;Player 2&#10;Player 3"></textarea>
            <div id="lobbyMultiIntro" class="small" style="display:none;">Who's currently in the lobby:</div>
            <div id="lobbyPlayers" class="lobbyList" style="display:none;"></div>
            <div class="modeCard" id="modeCard">
              <div class="small" style="margin-bottom:8px;">Game mode</div>
              <div class="modeRow">
              <button class="modeBtn active" id="modeHotseatBtn">Hotseat</button>
              <button class="modeBtn" id="modeMultiBtn">Multiplayer</button>
            </div>
            <div class="mpStatus" id="modeHint">Hotseat runs on one device. Multiplayer requires Google sign-in.</div>
          </div>
          <div class="mpCard" id="mpCard" style="display:none;">
            <div class="small" style="margin-bottom:8px;">Multiplayer</div>
            <div class="mpRow" style="margin-bottom:8px;">
              <button class="btn" id="signInBtn">Sign in with Google</button>
              <button class="btn danger" id="signOutBtn" style="display:none;">Sign out</button>
              <div class="mpStatus" id="authStatus">Not signed in.</div>
            </div>
              <div class="mpRow" style="margin-bottom:8px;">
                <input class="input mpCode" id="roomCodeInput" placeholder="ROOM CODE" />
                <button class="btn primary" id="createRoomBtn">Create Room</button>
                <button class="btn" id="joinRoomBtn">Join Room</button>
                <button class="btn" id="shareRoomBtn">Copy/Share</button>
              </div>
            <div class="mpStatus" id="roomStatus">No room joined.</div>
          </div>
          <button class="btn primary" id="startGameBtn">Start Game</button>
        </div>

        <div id="settingsCard" class="settingsCard">
          <div class="settingsHeader" id="settingsHeader" tabindex="0">
            <div style="display:flex;align-items:center;gap:8px;">
              <span class="caret" id="settingsCaret">‚ñæ</span>
              <div style="font-weight:900;">Game settings</div>
              <span id="settingsLockPill" class="pill" style="padding:4px 8px;border-radius:10px;font-size:11px;display:none;">Locked</span>
            </div>
          </div>
          <div class="settingsBody" id="settingsBody">
            <div class="settingRow">
              <div>
                <div class="settingLabel">Starting Score</div>
                <div class="settingMeta">5‚Äì50</div>
              </div>
              <div class="settingControls">
                <input id="startingScoreInput" type="range" min="5" max="50" step="1" value="20" />
                <div class="settingValue" id="startingScoreValue">20</div>
              </div>
            </div>
            <div class="settingRow">
              <div>
                <div class="settingLabel">DING Penalty</div>
                <div class="settingMeta">0 tricks in a hand</div>
              </div>
              <div class="settingValue">Reset to start</div>
            </div>
            <div class="settingRow">
              <div>
                <div class="settingLabel">Leader Fold Threshold</div>
                <div class="settingMeta">1‚ÄìStarting Score</div>
              </div>
              <div class="settingControls">
                <input id="foldThresholdInput" type="range" min="1" max="20" step="1" value="5" />
                <div class="settingValue" id="foldThresholdValue">5</div>
              </div>
            </div>
            <div class="settingRow">
              <div>
                <div class="settingLabel">Leader Fold Penalty</div>
                <div class="settingMeta">On fold below threshold</div>
              </div>
              <div class="settingValue">Reset to threshold</div>
            </div>
            <div class="settingRow">
              <div>
                <div class="settingLabel">Amount of Decks</div>
                <div class="settingMeta">1‚Äì2</div>
              </div>
              <div class="settingControls">
                <input id="deckCountInput" type="range" min="1" max="2" step="1" value="1" />
                <div class="settingValue" id="deckCountValue">1</div>
              </div>
            </div>
            <div class="settingRow">
              <div>
                <div class="settingLabel">Hyperrealistic Mode</div>
                <div class="settingMeta">No handholding</div>
              </div>
              <label class="settingToggle">
                <input id="hyperrealisticInput" type="checkbox" />
                OFF
              </label>
            </div>
          </div>
        </div>

        <div id="controlsArea" class="stack" style="display:none;">
          <div class="scoreboard" id="scoreboard"></div>

          <div id="statusBox" class="pill" style="justify-content:space-between;">
            <span id="statusText">‚Äî</span>
            <span class="mono" id="deckText"></span>
          </div>

            <div id="errorBox" class="error" style="display:none;"></div>
          </div>

          <div id="logCard" class="logCard collapsed">
            <div class="logHeader" id="logHeader" role="button" tabindex="0" aria-expanded="false">
              <span class="logCaret" id="logCaret">‚ñæ</span>
              <div style="font-weight:800;">Room log</div>
              <div class="small" id="logHint" style="margin-left:auto;color:var(--muted);">Collapsed</div>
            </div>
            <div class="logBody" id="logBody">
              <div class="logList" id="logList"></div>
            </div>
          </div>
        </div>
      </section>

    <section id="tablePanel" class="panel">
      <div id="tableHeader" class="hd">
        <div style="font-weight:900;"><span class="caret" id="tableCaret">‚ñæ</span>Table</div>
        <div class="row2">
          <div id="tableSummary" class="small mono" style="margin-right:8px;">‚Äî</div>
          <button class="btn collapseBtn" id="collapseTableBtn">‚ñæ</button>
          <div style="display:flex; gap:10px;">
            <div class="badge">Turn: <strong id="turnName">‚Äî</strong></div>
            <div class="badge">Dealer: <strong id="dealerName">‚Äî</strong></div>
            <div class="badge">Trick: <strong id="trickNum">‚Äî</strong></div>
          </div>
        </div>
      </div>
      <div class="bd tableArea">
        <div class="trickArea" id="trickArea"></div>

        <div id="handPanel" class="panel" style="border-radius:18px;">
          <div id="handHeader" class="hd">
            <div style="font-weight:900;">Your hand</div>
            <div class="row2">
              <div id="handSummary" class="small mono" style="margin-right:8px;">‚Äî</div>
              <button class="btn collapseBtn" id="collapseHandBtn">‚ñæ</button>
              <div style="display:flex; gap:8px; align-items:center;">
                <div class="badge" id="selectedBadge" style="display:none;">Selected: <strong id="selectedCount">0</strong></div>
                <button class="btn good" id="confirmSwapBtn" style="display:none;">Confirm Swap</button>
                <button class="btn primary" id="confirmPlayBtn" style="display:none;">Play selected card</button>
                <button class="btn primary" id="startHandBtn">Deal Hands</button>
                <!-- Pass button removed -->
                <div id="autoPassViz" style="display:none;align-items:center;gap:8px;">
                  <div class="autoPassRing" id="autoPassRing">3</div>
                  <div class="small" id="autoPassLabel" style="white-space:nowrap;color:var(--muted);">Auto-pass</div>
                </div>
                <button class="btn" id="passBtn" style="display:none;">Pass</button>
                <button class="btn danger" id="foldBtn" style="display:none;">Fold</button>
              </div>
            </div>
          </div>
          <div class="bd">
            <div class="small" id="handHint">Start a hand to see cards.</div>
            <div class="hand" id="handArea"></div>
          </div>
        </div>

      </div>
    </section>
  </div>
</main>

<div class="lock" id="lock">
  <div class="box">
    <h2 id="lockTitle">Pass the device</h2>
    <p id="lockText">Hand is hidden. Give the device to the next player, then tap reveal.</p>
    <div class="row2">
      <button class="btn primary" id="revealBtn" style="flex:1;">Reveal</button>
    </div>
    <div class="footerNote">No peeking üëÄ</div>
  </div>
</div>

<script src="firebase-config.js"></script>
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection, serverTimestamp, writeBatch, addDoc, query, orderBy, arrayUnion } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
/** =========================
 *  Ding Prototype (Hotseat)
 *  =========================
 *  Adjustable house rules:
 *  - Next hand dealer: set DEALER_RULE
 *    "LAST_TRICK_WINNER" (default) or "ROTATE"
 */
const DEALER_RULE = "ROTATE"; // or "ROTATE"

const SUITS = ["C","D","H","S"];
const SUIT_ICON = { C:"‚ô£", D:"‚ô¶", H:"‚ô•", S:"‚ô†" };
const RANK_LABEL = { 11:"J", 12:"Q", 13:"K", 14:"A" };

const PHASE = {
  LOBBY: "LOBBY",
  SWAP: "SWAP",
  TRICK: "TRICK",
  HAND_END: "HAND_END",
};
const MODE = {
  HOTSEAT: "HOTSEAT",
  MULTI: "MULTI",
};

const firebaseConfig = window.FIREBASE_CONFIG || null;
const firebaseApp = firebaseConfig ? initializeApp(firebaseConfig) : null;
const firebaseAuth = firebaseApp ? getAuth(firebaseApp) : null;
const firebaseDb = firebaseApp ? getFirestore(firebaseApp) : null;
const googleProvider = firebaseAuth ? new GoogleAuthProvider() : null;
const ROOM_COLLECTION = "rooms";
const USER_COLLECTION = "users";
const LOG_COLLECTION = "roomLog";
const MAX_PLAYERS = 6;

function makeDeck(){
  return makeDecks(1);
}
function makeDecks(count){
  const deck = [];
  for(let d=0; d<count; d++){
    for(const s of SUITS){
      for(let r=2;r<=14;r++){
        deck.push({ suit:s, rank:r, id:`${r}${s}_${d}` });
      }
    }
  }
  return deck;
}
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}
function cardLabel(c){
  const r = RANK_LABEL[c.rank] ?? String(c.rank);
  return `${r}${SUIT_ICON[c.suit]}`;
}
function isRedSuit(s){ return s==="H" || s==="D"; }

function rankValue(c){ return c.rank; }

function canFollowSuit(hand, suit){
  return hand.some(c => c.suit === suit);
}

function determineTrickWinner(plays, leadSuit, trumpSuit){
  // plays: [{playerIndex, card}]
  const trumps = plays.filter(p => p.card.suit === trumpSuit);
  const candidates = trumps.length ? trumps : plays.filter(p => p.card.suit === leadSuit);
  // highest rank wins; ties impossible in standard deck
  let best = candidates[0];
  for(const p of candidates){
    if(rankValue(p.card) > rankValue(best.card)) best = p;
  }
  return best.playerIndex;
}

// removed unused helper: clone()

const state = {
  mode: MODE.MULTI,
  phase: PHASE.LOBBY,
  lastPhase: PHASE.LOBBY,
  players: [],
  playerOrder: [],
  roomId: null,
  hostUid: null,
  selfUid: null,
  selfName: null,
  selfIndex: null,
  selfHand: [],
  isSignedIn: false,
  unsubRoom: null,
  unsubPlayers: null,
  unsubHand: null,
  unsubLog: null,
  isApplyingRemote: false,
  dealerIndex: 0,
  leaderIndex: 0,        // who leads the current trick
  currentTurnIndex: 0,   // whose action is required (swap or play)
  trickNumber: 0,
  deck: [],
  trumpCard: null,
  trumpSuit: null,
  currentTrick: { plays: [], leadSuit: null },
  handId: 0,
  selectedCardIds: new Set(),
  selectedForSwap: new Set(),
  // animation & deal helpers
  incomingCardIds: new Set(), // cards that should animate in
  // per-player initial reveal flags: players with pending initial reveal
  playersPendingInitial: new Set(),
  dealing: false,             // whether a deal animation is in progress
  dealTimeouts: [],          // timeout handles for canceling scheduled deals
  autoPassTimer: null,
  lockOn: false,
  pendingRevealForIndex: null,
  lastTrickWinnerIndex: null,
  lastCompletedTrick: null,
  winnerIndex: null,
  settings: {
    startingScore: 20,
    dingPenalty: "reset",
    foldThreshold: 5,
    foldPenalty: "threshold",
    decks: 1,
    hyperrealistic: false,
  },
  settingsCollapsed: false,
  discardPile: [],
  playedCards: [],
  logEntries: [],
  logCollapsed: true,
  collapsed: { game:false, table:false, hand:false },
};

const els = {
  phasePill: document.getElementById("phasePill"),
  trumpPill: document.getElementById("trumpPill"),
  leadPill: document.getElementById("leadPill"),
  headerGreeting: document.getElementById("headerGreeting"),

  lobbyArea: document.getElementById("lobbyArea"),
  controlsArea: document.getElementById("controlsArea"),
  namesInput: document.getElementById("namesInput"),
  startGameBtn: document.getElementById("startGameBtn"),
  startHandBtn: document.getElementById("startHandBtn"),
  resetBtn: document.getElementById("resetBtn"),
  modeHotseatBtn: document.getElementById("modeHotseatBtn"),
  modeMultiBtn: document.getElementById("modeMultiBtn"),
  modeHint: document.getElementById("modeHint"),
  mpCard: document.getElementById("mpCard"),
  signInBtn: document.getElementById("signInBtn"),
  signOutBtn: document.getElementById("signOutBtn"),
  authStatus: document.getElementById("authStatus"),
  roomCodeInput: document.getElementById("roomCodeInput"),
  createRoomBtn: document.getElementById("createRoomBtn"),
  joinRoomBtn: document.getElementById("joinRoomBtn"),
  shareRoomBtn: document.getElementById("shareRoomBtn"),
  roomStatus: document.getElementById("roomStatus"),
  lobbyHotseatIntro: document.getElementById("lobbyHotseatIntro"),
  lobbyMultiIntro: document.getElementById("lobbyMultiIntro"),
  lobbyPlayers: document.getElementById("lobbyPlayers"),
  logCard: document.getElementById("logCard"),
  logHeader: document.getElementById("logHeader"),
  logCaret: document.getElementById("logCaret"),
  logList: document.getElementById("logList"),
  logHint: document.getElementById("logHint"),

  scoreboard: document.getElementById("scoreboard"),
  statusText: document.getElementById("statusText"),
  deckText: document.getElementById("deckText"),
  errorBox: document.getElementById("errorBox"),

  trickArea: document.getElementById("trickArea"),
  handArea: document.getElementById("handArea"),
  handHint: document.getElementById("handHint"),
  autoPassViz: document.getElementById("autoPassViz"),
  autoPassRing: document.getElementById("autoPassRing"),
  autoPassLabel: document.getElementById("autoPassLabel"),
  passBtn: document.getElementById("passBtn"),
  selectedCount: document.getElementById("selectedCount"),
  confirmSwapBtn: document.getElementById("confirmSwapBtn"),
  confirmPlayBtn: document.getElementById("confirmPlayBtn"),

  turnName: document.getElementById("turnName"),
  dealerName: document.getElementById("dealerName"),
  trickNum: document.getElementById("trickNum"),

  lock: document.getElementById("lock"),
  lockTitle: document.getElementById("lockTitle"),
  lockText: document.getElementById("lockText"),
  revealBtn: document.getElementById("revealBtn"),
  foldBtn: document.getElementById("foldBtn"),
  settingsCard: document.getElementById("settingsCard"),
  settingsHeader: document.getElementById("settingsHeader"),
  settingsCaret: document.getElementById("settingsCaret"),
  settingsBody: document.getElementById("settingsBody"),
  settingsLockPill: document.getElementById("settingsLockPill"),
  startingScoreInput: document.getElementById("startingScoreInput"),
  startingScoreValue: document.getElementById("startingScoreValue"),
  foldThresholdInput: document.getElementById("foldThresholdInput"),
  foldThresholdValue: document.getElementById("foldThresholdValue"),
  deckCountInput: document.getElementById("deckCountInput"),
  deckCountValue: document.getElementById("deckCountValue"),
  hyperrealisticInput: document.getElementById("hyperrealisticInput"),
  gamePanel: document.getElementById("gamePanel"),
  tablePanel: document.getElementById("tablePanel"),
  handPanel: document.getElementById("handPanel"),
  gameHeader: document.getElementById("gameHeader"),
  tableHeader: document.getElementById("tableHeader"),
  handHeader: document.getElementById("handHeader"),
  gameCaret: document.getElementById("gameCaret"),
  tableCaret: document.getElementById("tableCaret"),
  handCaret: document.getElementById("handCaret"),
  collapseGameBtn: document.getElementById("collapseGameBtn"),
  collapseTableBtn: document.getElementById("collapseTableBtn"),
  collapseHandBtn: document.getElementById("collapseHandBtn"),
  gameSummary: document.getElementById("gameSummary"),
  tableSummary: document.getElementById("tableSummary"),
  handSummary: document.getElementById("handSummary"),
};

function syncSettingsUI(){
  const s = state.settings;
  if(els.startingScoreInput){
    els.startingScoreInput.value = String(s.startingScore);
    els.startingScoreValue.textContent = String(s.startingScore);
  }
  if(els.foldThresholdInput){
    els.foldThresholdInput.max = String(s.startingScore);
    els.foldThresholdInput.value = String(s.foldThreshold);
    els.foldThresholdValue.textContent = String(s.foldThreshold);
  }
  if(els.deckCountInput){
    els.deckCountInput.value = String(s.decks);
    els.deckCountValue.textContent = String(s.decks);
  }
  if(els.hyperrealisticInput){
    els.hyperrealisticInput.checked = !!s.hyperrealistic;
    const label = els.hyperrealisticInput.closest(".settingToggle");
    if(label) label.lastChild.nodeValue = s.hyperrealistic ? " ON" : " OFF";
  }
}

function clampSettings(){
  const s = state.settings;
  if(s.foldThreshold > s.startingScore) s.foldThreshold = s.startingScore;
  if(s.foldThreshold < 1) s.foldThreshold = 1;
  if(s.startingScore < 5) s.startingScore = 5;
  if(s.startingScore > 50) s.startingScore = 50;
  if(s.decks < 1) s.decks = 1;
  if(s.decks > 2) s.decks = 2;
}

function foldCurrentPlayer(){
  if(state.phase !== PHASE.SWAP) return;
  const isMulti = isMultiplayer();
  if(isMulti && state.selfIndex !== state.currentTurnIndex){
    setError("Not your turn.");
    return;
  }
  const p = isMulti ? state.players[state.selfIndex] : state.players[state.currentTurnIndex];
  if(!p || p.folded) return;
  if(state.currentTurnIndex === state.dealerIndex){
    setError("Dealer cannot fold.");
    return;
  }
  if(p.score < state.settings.foldThreshold) p.score = state.settings.foldThreshold;
  // mark folded and mark as swapped so they are excluded from further swap turns
  p.folded = true;
  p.hasSwapped = true;
  // move their hand to discard pile (also handle trump if present)
  const hand = isMulti ? state.selfHand : p.hand;
  if(hand && hand.length){
    // if trump is in their hand, clear the global trump reference
    const trumpIdx = hand.findIndex(c => state.trumpCard && c.id === state.trumpCard.id);
    if(trumpIdx !== -1){
      state.discardPile.push(...hand);
      state.trumpCard = null;
      state.trumpSuit = null;
    } else {
      state.discardPile.push(...hand);
    }
    if(isMulti){
      state.selfHand = [];
      syncSelfHand();
    } else {
      p.hand = [];
    }
  }
  state.selectedForSwap.clear();
  setError(null);
  render();

  // If too few players remain, end the hand immediately
  if(activePlayersCount() < 2){
    const remainingIdx = firstActiveIndex(0);
    if(remainingIdx !== null && remainingIdx === state.dealerIndex){
      state.players[remainingIdx].tricksWonThisHand = 5;
      state.lastTrickWinnerIndex = remainingIdx;
    }
    endHand();
    return;
  }

  // Otherwise advance to next unswapped/active player
  advanceSwapTurn();
  if(isMulti) syncRoomState("fold");
}

// wire fold button
if(els.foldBtn){
  els.foldBtn.addEventListener('click', ()=> foldCurrentPlayer());
} 

function setError(msg){
  if(!msg){
    els.errorBox.style.display = "none";
    els.errorBox.textContent = "";
    return;
  }
  els.errorBox.style.display = "block";
  els.errorBox.textContent = msg;
}

function isMultiplayer(){ return state.mode === MODE.MULTI; }
function hasFirebase(){ return !!(firebaseApp && firebaseAuth && firebaseDb); }
function roomRef(roomId){ return doc(firebaseDb, ROOM_COLLECTION, roomId); }
function userRef(uid){ return doc(firebaseDb, USER_COLLECTION, uid); }
function handRef(roomId, uid){ return doc(firebaseDb, ROOM_COLLECTION, roomId, "hands", uid); }
function logCollectionRef(roomId){ return collection(firebaseDb, ROOM_COLLECTION, roomId, LOG_COLLECTION); }
function flashRoomStatus(msg){
  if(!els.roomStatus) return;
  const prev = els.roomStatus.textContent;
  els.roomStatus.textContent = msg;
  setTimeout(()=>{ updateRoomStatus(); }, 2000);
}
function roomShareLink(code){
  const roomCode = normalizeRoomCode(code || state.roomId || "");
  if(!roomCode) return "";
  return `${location.origin}${location.pathname}#${roomCode}`;
}
async function shareRoomCode(){
  const roomCode = normalizeRoomCode(state.roomId || (els.roomCodeInput ? els.roomCodeInput.value : ""));
  if(!roomCode){
    setError("Create or join a room first.");
    return;
  }
  const link = roomShareLink(roomCode);
  try{
    if(navigator.share){
      await navigator.share({
        title: "DING Online - Room invite",
        text: `Join my DING room: ${roomCode}`,
        url: link,
      });
      return;
    }
  } catch (err){
    // fall back to clipboard
  }
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(link);
      flashRoomStatus("Room link copied.");
      return;
    }
  } catch (err){
    // fall back to input selection
  }
  if(els.roomCodeInput){
    els.roomCodeInput.value = roomCode;
    els.roomCodeInput.focus();
    els.roomCodeInput.select();
    document.execCommand("copy");
    flashRoomStatus("Room code copied.");
  }
}

function renderLobbyPlayers(){
  if(!els.lobbyPlayers) return;
  els.lobbyPlayers.innerHTML = "";
  if(state.mode !== MODE.MULTI){
    return;
  }
  const players = state.players || [];
  if(!players.length){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.textContent = "Your lobby is empty. 2-6 players are needed to start. Create a room and share the room code to invite players.";
    els.lobbyPlayers.appendChild(empty);
    return;
  }
  players.forEach((p)=>{
    const row = document.createElement("div");
    row.className = "lobbyPlayer";
    row.textContent = p.name || "Player";
    els.lobbyPlayers.appendChild(row);
  });
}

function normalizeRoomCode(code){
  return (code || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 8);
}
function makeRoomCode(){
  const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
  let code = "";
  for(let i=0;i<6;i++){
    code += chars[Math.floor(Math.random() * chars.length)];
  }
  return code;
}
function buildPlayer(uid, name){
  return {
    uid,
    name: name || "Player",
    hand: [],
    tricksWonThisHand: 0,
    wonTricks: [],
    score: state.settings.startingScore,
    dingCount: 0,
    hasSwapped: false,
    folded: false,
  };
}

function updateModeUI(){
  const isMulti = state.mode === MODE.MULTI;
  if(els.modeHotseatBtn) els.modeHotseatBtn.classList.toggle("active", !isMulti);
  if(els.modeMultiBtn) els.modeMultiBtn.classList.toggle("active", isMulti);
  if(els.mpCard) els.mpCard.style.display = isMulti ? "block" : "none";
  if(els.namesInput){
    els.namesInput.disabled = isMulti;
    els.namesInput.style.display = isMulti ? "none" : "block";
  }
  if(els.lobbyHotseatIntro) els.lobbyHotseatIntro.style.display = isMulti ? "none" : "block";
  if(els.lobbyMultiIntro) els.lobbyMultiIntro.style.display = isMulti ? "block" : "none";
  if(els.lobbyPlayers) els.lobbyPlayers.style.display = isMulti ? "flex" : "none";
  if(els.modeHint){
    if(!hasFirebase()){
      els.modeHint.textContent = "Multiplayer config missing. Multiplayer disabled.";
    } else {
      els.modeHint.textContent = isMulti
        ? ""
        : "Hotseat runs on one device.";
    }
  }
  if(els.modeMultiBtn) els.modeMultiBtn.disabled = !hasFirebase();
  renderLobbyPlayers();
  renderRoomLog();
}

function setMode(mode){
  if(mode === state.mode){
    updateModeUI();
    return;
  }
  if(mode === MODE.MULTI && !hasFirebase()){
    setError("Firebase config missing.");
    updateModeUI();
    return;
  }
  state.mode = mode;
  if(mode === MODE.HOTSEAT){
    leaveRoom();
    resetAll();
  }
  if(mode === MODE.MULTI){
    setLock(false, null);
    if(state.isSignedIn) maybeAutoJoinRoom();
  }
  updateModeUI();
  render();
}

function updateAuthUI(){
  if(!els.authStatus) return;
  if(state.isSignedIn){
    els.authStatus.textContent = `Signed in as ${state.selfName || "Player"}.`;
  } else {
    els.authStatus.textContent = "Not signed in.";
  }
  if(els.signInBtn) els.signInBtn.style.display = state.isSignedIn ? "none" : "inline-block";
  if(els.signOutBtn) els.signOutBtn.style.display = state.isSignedIn ? "inline-block" : "none";
  if(els.shareRoomBtn) els.shareRoomBtn.disabled = !state.roomId;
  if(els.headerGreeting){
    if(state.isSignedIn && state.selfName){
      els.headerGreeting.textContent = `Hi ${state.selfName} - welcome back.`;
      els.headerGreeting.style.display = "block";
    } else if(state.isSignedIn){
      els.headerGreeting.textContent = "Hi there - welcome back.";
      els.headerGreeting.style.display = "block";
    } else {
      els.headerGreeting.textContent = "";
      els.headerGreeting.style.display = "none";
    }
  }
}

function updateRoomStatus(){
  if(!els.roomStatus) return;
  if(!state.roomId){
    els.roomStatus.textContent = "";
    if(els.shareRoomBtn) els.shareRoomBtn.disabled = true;
    return;
  }
  const role = (state.selfUid && state.hostUid && state.selfUid === state.hostUid) ? "host" : "guest";
  els.roomStatus.textContent = `Room ${state.roomId} (${role}).`;
  if(els.roomCodeInput) els.roomCodeInput.value = state.roomId;
  if(els.shareRoomBtn) els.shareRoomBtn.disabled = false;
}

function leaveRoom(){
  if(state.unsubRoom){ state.unsubRoom(); state.unsubRoom = null; }
  if(state.unsubHand){ state.unsubHand(); state.unsubHand = null; }
  if(state.unsubLog){ state.unsubLog(); state.unsubLog = null; }
  state.roomId = null;
  state.hostUid = null;
  state.selfIndex = null;
  state.selfHand = [];
  state.players = [];
  state.logEntries = [];
  updateRoomStatus();
}

function serializeRoomState(){
  const players = state.players.map(p => ({
    uid: p.uid ?? null,
    name: p.name,
    tricksWonThisHand: p.tricksWonThisHand || 0,
    wonTricks: Array.isArray(p.wonTricks)
      ? p.wonTricks.map((trick)=>({
          plays: Array.isArray(trick) ? trick : (trick && Array.isArray(trick.plays) ? trick.plays : []),
        }))
      : [],
    score: typeof p.score === "number" ? p.score : state.settings.startingScore,
    dingCount: p.dingCount || 0,
    hasSwapped: !!p.hasSwapped,
    folded: !!p.folded,
  }));
  return {
    mode: MODE.MULTI,
    phase: state.phase,
    players,
    dealerIndex: state.dealerIndex,
    leaderIndex: state.leaderIndex,
    currentTurnIndex: state.currentTurnIndex,
    trickNumber: state.trickNumber,
    handId: state.handId,
    deck: state.deck,
    trumpCard: state.trumpCard,
    trumpSuit: state.trumpSuit,
    currentTrick: state.currentTrick,
    lastTrickWinnerIndex: state.lastTrickWinnerIndex,
    lastCompletedTrick: state.lastCompletedTrick,
    winnerIndex: state.winnerIndex,
    settings: state.settings,
    discardPile: state.discardPile,
    playedCards: state.playedCards,
    updatedAt: serverTimestamp(),
  };
}

function applyRoomState(data){
  if(!data) return;
  const prevPhase = state.phase;
  const prevTurn = state.currentTurnIndex;
  state.isApplyingRemote = true;
  try{
    state.mode = MODE.MULTI;
    state.phase = data.phase ?? state.phase;
    state.players = Array.isArray(data.players)
      ? data.players.map((p, idx)=>{
          const rawWonTricks = Array.isArray(p.wonTricks) ? p.wonTricks : [];
          const wonTricks = rawWonTricks.map((trick)=>{
            if(Array.isArray(trick)) return trick;
            if(trick && Array.isArray(trick.plays)) return trick.plays;
            return [];
          });
          return {
            id: p.id ?? `p${idx}`,
            uid: p.uid ?? null,
            name: p.name ?? "Player",
            hand: [],
            tricksWonThisHand: p.tricksWonThisHand || 0,
            wonTricks,
            score: typeof p.score === "number" ? p.score : state.settings.startingScore,
            dingCount: p.dingCount || 0,
            hasSwapped: !!p.hasSwapped,
            folded: !!p.folded,
          };
        })
      : state.players;
    state.dealerIndex = data.dealerIndex ?? state.dealerIndex;
    state.leaderIndex = data.leaderIndex ?? state.leaderIndex;
    state.currentTurnIndex = data.currentTurnIndex ?? state.currentTurnIndex;
    state.trickNumber = data.trickNumber ?? state.trickNumber;
    state.handId = data.handId ?? state.handId;
    state.deck = Array.isArray(data.deck) ? data.deck : state.deck;
    state.trumpCard = data.trumpCard ?? null;
    state.trumpSuit = data.trumpSuit ?? null;
    state.currentTrick = data.currentTrick || { plays: [], leadSuit: null };
    state.lastTrickWinnerIndex = data.lastTrickWinnerIndex ?? null;
    state.lastCompletedTrick = data.lastCompletedTrick ?? null;
    state.winnerIndex = data.winnerIndex ?? null;
    state.settings = { ...state.settings, ...(data.settings || {}) };
    state.discardPile = Array.isArray(data.discardPile) ? data.discardPile : [];
    state.playedCards = Array.isArray(data.playedCards) ? data.playedCards : [];
    state.hostUid = data.hostUid ?? state.hostUid;
    state.selfIndex = state.players.findIndex(p => p.uid === state.selfUid);
    if(state.selfIndex < 0) state.selfHand = [];
    state.lockOn = false;
    state.pendingRevealForIndex = null;
    if(prevPhase !== state.phase || prevTurn !== state.currentTurnIndex){
      state.selectedCardIds.clear();
      state.selectedForSwap.clear();
    }
  } finally {
    state.isApplyingRemote = false;
  }
  syncSettingsUI();
  updateModeUI();
  updateRoomStatus();
  renderLobbyPlayers();
  render();
}

async function syncRoomState(reason){
  if(!isMultiplayer() || !state.roomId || !firebaseDb) return;
  if(state.isApplyingRemote) return;
  try{
    const payload = serializeRoomState();
    if(state.hostUid) payload.hostUid = state.hostUid;
    await setDoc(roomRef(state.roomId), payload, { merge: true });
    updateRoomStatus();
  } catch (err){
    console.error("Failed to sync room state:", reason, err);
    setError("Failed to sync room state.");
  }
}

function subscribeToRoom(roomId){
  if(state.unsubRoom){ state.unsubRoom(); state.unsubRoom = null; }
  state.mode = MODE.MULTI;
  state.roomId = roomId;
  updateRoomStatus();
  const ref = roomRef(roomId);
  state.unsubRoom = onSnapshot(ref, (snap)=>{
    if(!snap.exists()){
      setError("Room not found.");
      return;
    }
    applyRoomState(snap.data());
  }, (err)=>{
    console.error("Room subscription error:", err);
    setError("Room sync failed.");
  });
}

function subscribeToHand(){
  if(state.unsubHand){ state.unsubHand(); state.unsubHand = null; }
  if(!state.roomId || !state.selfUid || !firebaseDb) return;
  const ref = handRef(state.roomId, state.selfUid);
  state.unsubHand = onSnapshot(ref, (snap)=>{
    if(!snap.exists()){
      state.selfHand = [];
      render();
      return;
    }
    const data = snap.data();
    state.selfHand = Array.isArray(data.hand) ? data.hand : [];
    render();
  }, (err)=>{
    console.error("Hand subscription error:", err);
  });
}

async function syncSelfHand(){
  if(!isMultiplayer() || !state.roomId || !state.selfUid || !firebaseDb) return;
  try{
    await setDoc(handRef(state.roomId, state.selfUid), {
      hand: state.selfHand,
      updatedAt: serverTimestamp(),
    }, { merge: true });
  } catch (err){
    console.error("Failed to sync hand:", err);
    setError("Failed to sync hand.");
  }
}

function subscribeToLog(){
  if(state.unsubLog){ state.unsubLog(); state.unsubLog = null; }
  if(!state.roomId || !firebaseDb) return;
  const q = query(logCollectionRef(state.roomId), orderBy("createdAt", "asc"));
  state.unsubLog = onSnapshot(q, (snap)=>{
    state.logEntries = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    renderRoomLog();
  }, (err)=>{
    console.error("Log subscription error:", err);
  });
}

async function logRoomEvent(entry){
  if(!isMultiplayer() || !state.roomId || !firebaseDb) return;
  try{
    await addDoc(logCollectionRef(state.roomId), {
      ...entry,
      createdAt: serverTimestamp(),
    });
  } catch (err){
    console.error("Failed to write log entry:", err);
  }
}

function renderRoomLog(){
  if(!els.logList) return;
  els.logList.innerHTML = "";
  let hint = "Multiplayer only";
  if(state.mode !== MODE.MULTI){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.textContent = "Room log is available in multiplayer.";
    els.logList.appendChild(empty);
  } else if(!state.roomId){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.textContent = "Join a room to see the log.";
    els.logList.appendChild(empty);
    hint = "No room";
  } else if(!state.logEntries.length){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.textContent = "No hands logged yet.";
    els.logList.appendChild(empty);
    hint = "No hands yet";
  } else {
    const hands = new Map();
    state.logEntries.forEach((entry)=>{
      const handId = Number(entry.handId || 0);
      if(!handId) return;
      if(!hands.has(handId)) hands.set(handId, { plays: [], end: null });
      const hand = hands.get(handId);
      if(entry.type === "play") hand.plays.push(entry);
      if(entry.type === "hand_end") hand.end = entry;
    });
    const handIds = Array.from(hands.keys()).sort((a,b)=>a-b);
    hint = `${handIds.length} hand${handIds.length === 1 ? "" : "s"}`;
    handIds.forEach((handId)=>{
      const hand = hands.get(handId);
      const details = document.createElement("details");
      details.className = "handLog";
      const summary = document.createElement("summary");
      const title = document.createElement("div");
      title.className = "handTitle";
      const scores = (hand.end && Array.isArray(hand.end.scores)) ? hand.end.scores : [];
      const scoreLine = scores.length
        ? scores.map(s => `${s.name}: ${s.score}`).join(" ¬∑ ")
        : `Hand ${handId} (in progress)`;
      title.textContent = scoreLine;
      const meta = document.createElement("div");
      meta.className = "handScores";
      meta.textContent = scores.length ? `Hand ${handId}` : "Scores pending";
      summary.appendChild(title);
      summary.appendChild(meta);
      details.appendChild(summary);

      const playsByTrick = new Map();
      hand.plays.forEach((play)=>{
        const trick = Number(play.trickNumber || 0);
        if(!playsByTrick.has(trick)) playsByTrick.set(trick, []);
        playsByTrick.get(trick).push(play);
      });
      const trickIds = Array.from(playsByTrick.keys()).sort((a,b)=>a-b);
      const playsWrap = document.createElement("div");
      playsWrap.className = "handPlays";
      trickIds.forEach((trickId)=>{
        const trickBlock = document.createElement("div");
        trickBlock.className = "trickLog";
        const trickTitle = document.createElement("div");
        trickTitle.className = "small";
        trickTitle.textContent = `Trick ${trickId}`;
        trickBlock.appendChild(trickTitle);
        playsByTrick.get(trickId).forEach((play)=>{
          const line = document.createElement("div");
          line.className = "playLine";
          const name = play.playerName || "Player";
          const card = play.card ? cardLabel(play.card) : "‚Äî";
          line.innerHTML = `<span>${name}</span><span>${card}</span>`;
          trickBlock.appendChild(line);
        });
        playsWrap.appendChild(trickBlock);
      });
      if(!playsWrap.childNodes.length){
        const empty = document.createElement("div");
        empty.className = "small";
        empty.textContent = "No plays recorded.";
        playsWrap.appendChild(empty);
      }
      details.appendChild(playsWrap);
      els.logList.appendChild(details);
    });
  }
  if(els.logHint) els.logHint.textContent = hint;
  requestAnimationFrame(()=> scrollLogToBottom());
}

function scrollLogToBottom(){
  if(!els.logList) return;
  els.logList.scrollTop = els.logList.scrollHeight;
}

async function maybeAutoJoinRoom(){
  if(!state.isSignedIn || !hasFirebase()) return;
  if(state.roomId) return;
  const hashRoom = normalizeRoomCode(location.hash.replace("#", ""));
  if(hashRoom){
    await joinRoom(hashRoom);
    return;
  }
  try{
    const snap = await getDoc(userRef(state.selfUid));
    const lastRoomId = snap.exists() ? snap.data().lastRoomId : null;
    if(lastRoomId){
      await joinRoom(lastRoomId);
    }
  } catch (err){
    console.error("Auto-join failed:", err);
  }
}

async function createRoom(){
  if(!state.isSignedIn){ setError("Sign in first."); return; }
  if(!hasFirebase()){ setError("Firebase config missing."); return; }
  state.handId = 0;
  let roomId = "";
  for(let i=0;i<5;i++){
    const candidate = makeRoomCode();
    const snap = await getDoc(roomRef(candidate));
    if(!snap.exists()){
      roomId = candidate;
      break;
    }
  }
  if(!roomId){
    setError("Couldn't create a room. Try again.");
    return;
  }
  const player = buildPlayer(state.selfUid, state.selfName || "Player");
  const roomState = {
    hostUid: state.selfUid,
    createdAt: serverTimestamp(),
    ...serializeRoomState(),
    phase: PHASE.LOBBY,
    players: [player],
    dealerIndex: 0,
    leaderIndex: 0,
    currentTurnIndex: 0,
    trickNumber: 0,
    deck: [],
    trumpCard: null,
    trumpSuit: null,
    currentTrick: { plays: [], leadSuit: null },
    lastTrickWinnerIndex: null,
    lastCompletedTrick: null,
    winnerIndex: null,
    discardPile: [],
    playedCards: [],
  };
  await setDoc(roomRef(roomId), roomState);
  await setDoc(userRef(state.selfUid), { lastRoomId: roomId }, { merge: true });
  if(els.roomCodeInput) els.roomCodeInput.value = roomId;
  location.hash = roomId;
  subscribeToRoom(roomId);
  subscribeToHand();
  subscribeToLog();
}

async function joinRoom(roomId){
  if(!state.isSignedIn){ setError("Sign in first."); return; }
  if(!hasFirebase()){ setError("Firebase config missing."); return; }
  const code = normalizeRoomCode(roomId || (els.roomCodeInput ? els.roomCodeInput.value : ""));
  if(!code){
    setError("Enter a valid room code.");
    return;
  }
  const snap = await getDoc(roomRef(code));
  if(!snap.exists()){
    setError("Room not found.");
    return;
  }
  const data = snap.data();
  const players = Array.isArray(data.players) ? data.players.slice() : [];
  const existingIdx = players.findIndex(p => p.uid === state.selfUid);
  if(existingIdx === -1){
    if(data.phase && data.phase !== PHASE.LOBBY){
      setError("Game already in progress.");
      return;
    }
    if(players.length >= MAX_PLAYERS){
      setError("Room is full.");
      return;
    }
    players.push(buildPlayer(state.selfUid, state.selfName || "Player"));
    await updateDoc(roomRef(code), { players });
  }
  await setDoc(userRef(state.selfUid), { lastRoomId: code }, { merge: true });
  if(els.roomCodeInput) els.roomCodeInput.value = code;
  location.hash = code;
  subscribeToRoom(code);
  subscribeToHand();
  subscribeToLog();
}

async function startMultiplayerGame(){
  if(!state.roomId){
    setError("Join a room first.");
    return;
  }
  if(state.selfUid !== state.hostUid){
    setError("Only the host can start the game.");
    return;
  }
  if(state.players.length < 2){
    setError("Need at least 2 players.");
    return;
  }
  const players = state.players.map(p => buildPlayer(p.uid, p.name));
  state.players = players;
  state.phase = PHASE.HAND_END;
  state.dealerIndex = 0;
  state.leaderIndex = 0;
  state.currentTurnIndex = 0;
  state.trickNumber = 0;
  state.deck = [];
  state.handId = 0;
  state.trumpCard = null;
  state.trumpSuit = null;
  state.currentTrick = { plays: [], leadSuit: null };
  state.lastTrickWinnerIndex = null;
  state.lastCompletedTrick = null;
  state.winnerIndex = null;
  state.discardPile = [];
  state.playedCards = [];
  state.selectedCardIds.clear();
  state.selectedForSwap.clear();
  state.settingsCollapsed = true;
  state.selfHand = [];
  if(firebaseDb && state.roomId){
    const batch = writeBatch(firebaseDb);
    for(const p of state.players){
      if(p.uid){
        batch.set(handRef(state.roomId, p.uid), { hand: [], updatedAt: serverTimestamp() }, { merge: true });
      }
    }
    batch.commit().catch((err)=>{
      console.error("Failed to reset hands:", err);
    });
  }
  syncRoomState("start-game");
}

async function resetRoomState(){
  if(!state.roomId || !isMultiplayer()){
    resetAll();
    return;
  }
  if(state.selfUid !== state.hostUid){
    setError("Only the host can reset the room.");
    return;
  }
  const players = state.players.map(p => buildPlayer(p.uid, p.name));
  state.players = players;
  state.phase = PHASE.LOBBY;
  state.dealerIndex = 0;
  state.leaderIndex = 0;
  state.currentTurnIndex = 0;
  state.trickNumber = 0;
  state.deck = [];
  state.trumpCard = null;
  state.trumpSuit = null;
  state.currentTrick = { plays: [], leadSuit: null };
  state.lastTrickWinnerIndex = null;
  state.lastCompletedTrick = null;
  state.winnerIndex = null;
  state.discardPile = [];
  state.playedCards = [];
  state.selectedCardIds.clear();
  state.selectedForSwap.clear();
  state.selfHand = [];
  if(firebaseDb && state.roomId){
    const batch = writeBatch(firebaseDb);
    for(const p of state.players){
      if(p.uid){
        batch.set(handRef(state.roomId, p.uid), { hand: [], updatedAt: serverTimestamp() }, { merge: true });
      }
    }
    batch.commit().catch((err)=>{
      console.error("Failed to reset hands:", err);
    });
  }
  syncRoomState("reset");
}

// Toggle to temporarily disable lock behavior while testing.
// Set to `false` to restore normal lock UI/behavior.
const LOCKS_DISABLED = false;

function setLock(on, forIndex=null){
  if(isMultiplayer()){
    state.lockOn = false;
    state.pendingRevealForIndex = null;
    if (els && els.lock) els.lock.style.display = "none";
    return;
  }
  // Short-circuit lock behavior when disabled for tests.
  if (typeof LOCKS_DISABLED !== "undefined" && LOCKS_DISABLED) {
    state.lockOn = false;
    state.pendingRevealForIndex = null;
    if (els && els.lock) els.lock.style.display = "none";
    return;
  }

  state.lockOn = on;
  state.pendingRevealForIndex = forIndex;
  els.lock.style.display = on ? "flex" : "none";
  if(on && forIndex !== null){
    const name = state.players[forIndex]?.name ?? "Next player";
    const isSelf = forIndex === state.currentTurnIndex;
    // special messaging for a player who just swapped and needs to inspect new cards
    if(state.phase === PHASE.SWAP && state.players[forIndex]?.hasSwapped){
      els.lockTitle.textContent = `Inspect ${name}`;
      els.lockText.textContent = `You just swapped ‚Äî tap Reveal to inspect your new cards. Press Pass when ready.`;
    } else {
      els.lockTitle.textContent = `Pass to ${name}`;
      els.lockText.textContent = `Give the device to ${name}. Tap reveal when ready.`;
    }
  }
}

function resetAll(){
  state.phase = PHASE.LOBBY;
  state.lastPhase = PHASE.LOBBY;
  state.players = [];
  state.selfHand = [];
  state.dealerIndex = 0;
  state.leaderIndex = 0;
  state.currentTurnIndex = 0;
  state.trickNumber = 0;
  state.deck = [];
  state.trumpCard = null;
  state.trumpSuit = null;
  state.currentTrick = { plays: [], leadSuit: null };
  state.selectedCardIds = new Set();
  state.selectedForSwap = new Set();
  state.incomingCardIds.clear();
  state.playersPendingInitial.clear();
  state.dealTimeouts.forEach(t => clearTimeout(t));
  state.dealTimeouts = [];
  if(state.autoPassTimer){ clearInterval(state.autoPassTimer); state.autoPassTimer = null; }
  state.dealing = false;
  state.lastTrickWinnerIndex = null;
  state.lastCompletedTrick = null;
  state.winnerIndex = null;
  state.discardPile = [];
  state.playedCards = [];
  state.collapsed = { game:false, table:false, hand:false };
  state.settingsCollapsed = false;
  clampSettings();
  syncSettingsUI();
  setLock(false, null);
  setError(null);
  render();
}

// collapse toggles: only Game header is collapsible; Table & Hand are fixed open
if(els.gameHeader){
  els.gameHeader.style.cursor = 'pointer';
  els.gameHeader.tabIndex = 0;
  const toggleGame = ()=>{ state.collapsed.game = !state.collapsed.game; render(); };
  els.gameHeader.addEventListener('click', toggleGame);
  els.gameHeader.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggleGame(); } });
  // prevent clicks on the right-side header controls from toggling the header
  const gameRow = els.gameHeader.querySelector('.row2'); if(gameRow){ gameRow.addEventListener('click', e=>e.stopPropagation()); gameRow.addEventListener('keydown', e=>e.stopPropagation()); }
}
// tableHeader and handHeader are intentionally not made collapsible here

function initPlayers(names){
  state.players = names.map((n,i)=>({
    id: `p${i}`,
    name: n,
    hand: [],
    tricksWonThisHand: 0,
    wonTricks: [],
    score: state.settings.startingScore,
    dingCount: 0,
    hasSwapped: false,
    folded: false,
  }));
  state.dealerIndex = 0;
  state.leaderIndex = 0;
  state.currentTurnIndex = 0;
  state.winnerIndex = null;
}

function dealHand(){
  setError(null);
  if(state.dealing) return;
  if(isMultiplayer()){
    if(state.phase !== PHASE.HAND_END){
      setError("Can't deal: finish the current hand first.");
      return;
    }
    if(state.selfIndex === null || state.selfIndex !== state.dealerIndex){
      setError("Only the dealer can deal.");
      return;
    }
    state.dealing = true;
    state.handId = (state.handId || 0) + 1;

    // reset hand-only fields
    const handsByUid = new Map();
    for(const p of state.players){
      p.tricksWonThisHand = 0;
      p.wonTricks = [];
      p.hasSwapped = false;
      p.folded = false;
      if(p.uid) handsByUid.set(p.uid, []);
    }
    state.deck = shuffle(makeDecks(state.settings.decks));
    state.incomingCardIds.clear();
    state.playersPendingInitial.clear();

    for(let i=0;i<5;i++){
      for(const p of state.players){
        const hand = handsByUid.get(p.uid);
        if(hand && state.deck.length){
          hand.push(state.deck.pop());
        }
      }
    }

    const dealerUid = state.players[state.dealerIndex]?.uid;
    const dealerHand = dealerUid ? handsByUid.get(dealerUid) : null;
    if(dealerHand && dealerHand.length){
      state.trumpCard = dealerHand[dealerHand.length - 1];
      state.trumpSuit = state.trumpCard.suit;
    } else {
      state.trumpCard = null;
      state.trumpSuit = null;
    }

    state.selfHand = handsByUid.get(state.selfUid) || [];
    if(firebaseDb && state.roomId){
      const batch = writeBatch(firebaseDb);
      for(const [uid, hand] of handsByUid.entries()){
        batch.set(handRef(state.roomId, uid), { hand, updatedAt: serverTimestamp() }, { merge: true });
      }
      batch.commit().catch((err)=>{
        console.error("Failed to deal hands:", err);
        setError("Failed to deal hands.");
      });
    }

    state.phase = PHASE.SWAP;
    state.currentTurnIndex = firstActiveIndex((state.dealerIndex + 1) % state.players.length);
    state.leaderIndex = state.dealerIndex;
    state.trickNumber = 0;
    state.currentTrick = { plays: [], leadSuit: null };
    state.selectedCardIds.clear();
    state.selectedForSwap.clear();
    state.dealTimeouts.forEach(t=> clearTimeout(t));
    state.dealTimeouts = [];
    state.dealing = false;
    state.lockOn = false;
    state.pendingRevealForIndex = null;
    syncRoomState("deal");
    render();
    return;
  }
  state.dealing = true;
  state.handId = (state.handId || 0) + 1;

  // reset hand-only fields
  for(const p of state.players){
    p.hand = [];
    p.tricksWonThisHand = 0;
    p.wonTricks = [];
    p.hasSwapped = false;
    p.folded = false;
  }
  state.deck = shuffle(makeDecks(state.settings.decks));

  // clear any pending incoming flags and per-player initial reveal markers
  state.incomingCardIds.clear();
  state.playersPendingInitial.clear();

  // deal 5 cards to each player instantly, but DO NOT animate them yet
  for(let i=0;i<5;i++){
    for(const p of state.players){
      p.hand.push(state.deck.pop());
    }
  }

  // mark everyone as needing an initial reveal animation when they press Reveal
  // set the initial trump card to dealer's last dealt card (dealer keeps it)
  const dealer = state.players[state.dealerIndex];
  if(dealer && dealer.hand.length){
    state.trumpCard = dealer.hand[dealer.hand.length - 1];
    state.trumpSuit = state.trumpCard.suit;
  } else {
    state.trumpCard = null;
    state.trumpSuit = null;
  }
  // finalize swap state and animate the dealt cards into each player's hand
  state.phase = PHASE.SWAP;
  state.currentTurnIndex = firstActiveIndex((state.dealerIndex + 1) % state.players.length); // swap starts left of dealer
  state.leaderIndex = state.dealerIndex; // per rules: dealer leads first trick
  state.trickNumber = 0;
  state.currentTrick = { plays: [], leadSuit: null };
  state.selectedCardIds.clear();
  state.selectedForSwap.clear();

  // Removing per-card fly-in animations: perform an immediate, non-animated deal.
  state.dealTimeouts.forEach(t=> clearTimeout(t));
  state.dealTimeouts = [];
  state.dealing = false;

  // after dealing, require initial reveal for each player (so Reveal can animate if desired)
  for(let i=0;i<state.players.length;i++) state.playersPendingInitial.add(i);
  // lock to first swap player (left of dealer)
  setLock(true, state.currentTurnIndex);
  render();
}

// removed unused helper: allPlayersSwapped()

function advanceSwapTurn(){
  // next player in order who hasn't swapped
  for(let k=1;k<=state.players.length;k++){
    const idx = (state.currentTurnIndex + k) % state.players.length;
    if(!state.players[idx].hasSwapped){
      state.currentTurnIndex = idx;
      state.selectedForSwap.clear();
      setLock(true, idx);
      render();
      return;
    }
  }
  // everyone swapped
  state.phase = PHASE.TRICK;
  state.trickNumber = 1;
  state.currentTurnIndex = firstActiveIndex(state.leaderIndex);
  state.currentTrick = { plays: [], leadSuit: null };
  state.selectedCardIds.clear();
  setLock(true, state.currentTurnIndex);
  render();
}

// Find the next player index (starting at 'start') who has NOT swapped yet. Returns null if all have swapped.
// removed unused helper: nextUnswappedIndex()

// Return the first active (non-folded) index at or after `start`, or null if none
function firstActiveIndex(start){
  if(!state.players.length) return null;
  for(let k=0;k<state.players.length;k++){
    const idx = (start + k) % state.players.length;
    if(!state.players[idx].folded) return idx;
  }
  return null;
}

// Return next active index AFTER `idx`, or null if none
function getNextActiveIndex(idx){
  if(!state.players.length) return null;
  for(let k=1;k<=state.players.length;k++){
    const i = (idx + k) % state.players.length;
    if(!state.players[i].folded) return i;
  }
  return null;
}

function activePlayersCount(){
  return state.players.reduce((n,p)=> n + (p.folded ? 0 : 1), 0);
}

function confirmSwap(){
  if(isMultiplayer()){
    confirmSwapMultiplayer();
    return;
  }
  setError(null);
  if(state.phase !== PHASE.SWAP) return;
  const p = state.players[state.currentTurnIndex];

  // prevent multiple swaps per hand
  if(p.hasSwapped){ setError("You have already swapped this hand."); return; }

  const discards = Array.from(state.selectedForSwap);
  // record discarded card objects into discard pile
  if(discards.length){
    const discardedCards = p.hand.filter(c => discards.includes(c.id));
    state.discardPile.push(...discardedCards);
  }
  if(discards.length > 3){
    setError("You can swap at most 3 cards.");
    return;
  }
  if(state.dealing){ setError("Deal animation in progress."); return; }

  // if nothing selected, interpret as a 0-card swap (allowed), but still mark as swapped

  // replace each selected card in-place, left-to-right, with animated out/in sequence (~350ms per card)
  const positions = Array.from(state.selectedForSwap)
    .map(id => ({ id, idx: p.hand.findIndex(c => c.id===id) }))
    .filter(x => x.idx !== -1)
    .sort((a,b)=> a.idx - b.idx);

  // mark those discards into discard pile (by object)
  for(const pos of positions){
    const discarded = p.hand[pos.idx];
    if(discarded) state.discardPile.push(discarded);
  }

  // function for delay
  const sleep = (ms)=> new Promise(r=> setTimeout(r, ms));

  // sequentially replace
  (async ()=>{
    const perCardMs = Math.max(300, Math.floor(1000 / Math.max(1, positions.length)) ); // approx 1s total distributed
    for(const pos of positions){
      const id = pos.id;
      // animate outgoing clone if present
      const node = els.handArea.querySelector(`[data-card-id="${id}"]`);
      if(node){
        const rect = node.getBoundingClientRect();
        const clone = node.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.left = rect.left + 'px';
        clone.style.top = rect.top + 'px';
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.margin = '0';
        clone.style.zIndex = 9999;
        document.body.appendChild(clone);
        requestAnimationFrame(()=> clone.classList.add('fly-out'));
        // remove clone after animation
        setTimeout(()=> clone.remove(), Math.max(360, perCardMs));
      }

      // actually remove the card at the target index (use current hand state - indices shift as we replace sequentially)
      const curIdx = p.hand.findIndex(c => c.id === id);
      if(curIdx !== -1) p.hand.splice(curIdx, 1);

      // draw one replacement and insert at same index
      if(state.deck.length){
        const card = state.deck.pop();
        const insertIdx = Math.min(curIdx === -1 ? p.hand.length : curIdx, p.hand.length);
        p.hand.splice(insertIdx, 0, card);
        state.incomingCardIds.add(card.id);
        render();
        // hold the incoming indicator for the per-card interval
        await sleep(perCardMs);
        state.incomingCardIds.delete(card.id);
        render();
      } else {
        // no card to draw; continue after a short pause
        await sleep(perCardMs);
      }
    }

    p.hasSwapped = true;
    state.selectedForSwap.clear();
    // leave device unlocked so player can immediately inspect their new cards without clicking Reveal
    setLock(false, null);
    render();

    // start auto-pass countdown: inform user and advance after 3s (if still in SWAP)
    if(state.phase === PHASE.SWAP){
      state.autoPassCountdown = 3;
      if(state.autoPassTimer){ clearInterval(state.autoPassTimer); }
      state.autoPassTimer = setInterval(()=>{
        state.autoPassCountdown -= 1;
        if(state.autoPassCountdown <= 0){
          clearInterval(state.autoPassTimer);
          state.autoPassTimer = null;
          state.autoPassCountdown = null;
          // only advance if still in SWAP phase
          if(state.phase === PHASE.SWAP){
            advanceSwapTurn();
          }
          render();
        } else {
          render();
        }
      }, 1000);
    }
  })();

  // No-op for trump here (trump already set at deal)


  // Trump already set during deal; do not draw an extra trump here.
}

function confirmSwapMultiplayer(){
  setError(null);
  if(state.phase !== PHASE.SWAP) return;
  if(state.selfIndex === null || state.selfIndex !== state.currentTurnIndex){
    setError("Not your turn.");
    return;
  }
  const p = state.players[state.selfIndex];
  if(!p){
    setError("Player not found.");
    return;
  }
  if(!Array.isArray(state.selfHand)){
    setError("Hand not loaded.");
    return;
  }
  if(p.hasSwapped){
    setError("You have already swapped this hand.");
    return;
  }
  const discards = Array.from(state.selectedForSwap);
  if(discards.length > 3){
    setError("You can swap at most 3 cards.");
    return;
  }
  if(state.dealing){
    setError("Deal in progress.");
    return;
  }

  const workingHand = (state.selfHand || []).slice();
  for(const id of discards){
    const curIdx = workingHand.findIndex(c => c.id === id);
    if(curIdx === -1) continue;
    const discarded = workingHand[curIdx];
    if(discarded) state.discardPile.push(discarded);
    workingHand.splice(curIdx, 1);
    if(state.deck.length){
      const card = state.deck.pop();
      const insertIdx = Math.min(curIdx, workingHand.length);
      workingHand.splice(insertIdx, 0, card);
    }
  }

  state.selfHand = workingHand;
  syncSelfHand();
  p.hasSwapped = true;
  state.selectedForSwap.clear();
  if(state.autoPassTimer){ clearInterval(state.autoPassTimer); state.autoPassTimer = null; }
  state.autoPassCountdown = null;

  // advance swap turn or move to trick
  advanceSwapTurn();
  syncRoomState("swap");
}

function playableCardIdsForCurrentPlayer(){
  const isMulti = isMultiplayer();
  if(isMulti && state.selfIndex !== state.currentTurnIndex) return new Set();
  const p = isMulti ? state.players[state.selfIndex] : state.players[state.currentTurnIndex];
  const hand = isMulti ? state.selfHand : (p ? p.hand : null);
  if(!hand) return new Set();
  const lead = state.currentTrick.leadSuit;
  if(!lead) return new Set(hand.map(c=>c.id));
  if(canFollowSuit(hand, lead)){
    return new Set(hand.filter(c=>c.suit===lead).map(c=>c.id));
  }
  return new Set(hand.map(c=>c.id));
}

function playSelectedCard(){
  setError(null);
  if(state.phase !== PHASE.TRICK) return;
  const isMulti = isMultiplayer();
  if(isMulti && state.selfIndex !== state.currentTurnIndex){
    setError("Not your turn.");
    return;
  }
  const selected = Array.from(state.selectedCardIds);
  if(selected.length !== 1){
    setError("Select exactly 1 card to play.");
    return;
  }
  const p = isMulti ? state.players[state.selfIndex] : state.players[state.currentTurnIndex];
  const hand = isMulti ? state.selfHand : (p ? p.hand : null);
  if(!p){
    setError("Player not found.");
    return;
  }
  if(!hand){
    setError("Hand not loaded.");
    return;
  }
  const card = hand.find(c => c.id === selected[0]);
  if(!card){
    setError("That card isn't in your hand.");
    return;
  }
  // enforce follow suit unless hyperrealistic mode is on
  const lead = state.currentTrick.leadSuit;
  if(!state.settings.hyperrealistic && lead){
    if(canFollowSuit(hand, lead) && card.suit !== lead){
      setError(`You must follow suit (${SUIT_ICON[lead]}) if you can.`);
      return;
    }
  }
  // animate play: clone the card DOM and fly it to the trick area, then commit the play
  const node = els.handArea.querySelector(`[data-card-id="${card.id}"]`);
  const syncIfMulti = ()=>{ if(isMulti) syncRoomState("play"); };
  const commitPlay = ()=>{
    // commit play
    if(isMulti){
      state.selfHand = state.selfHand.filter(c => c.id !== card.id);
      syncSelfHand();
    } else {
      p.hand = p.hand.filter(c => c.id !== card.id);
    }
    state.currentTrick.plays.push({ playerIndex: state.currentTurnIndex, card });
    if(isMulti){
      const name = state.players[state.currentTurnIndex]?.name ?? "Player";
      logRoomEvent({
        type: "play",
        handId: state.handId,
        trickNumber: state.trickNumber,
        playerIndex: state.currentTurnIndex,
        playerName: name,
        card: { suit: card.suit, rank: card.rank, id: card.id },
      });
    }
    if(!state.currentTrick.leadSuit){
      state.currentTrick.leadSuit = card.suit;
      // a new trick is starting: clear the previous completed trick that was left on the table
      state.lastCompletedTrick = null;
    }
    state.selectedCardIds.clear();
    // mark this card as recently played so renderTrickArea can add an entry animation
    state.lastPlayedCardId = card.id;
    render();
    // clear the marker after the animation window
    setTimeout(()=>{ state.lastPlayedCardId = null; render(); }, 520);
    // continue with logic after render
    // if trick complete:
    if(state.currentTrick.plays.length === activePlayersCount()){
      const winnerIdx = determineTrickWinner(state.currentTrick.plays, state.currentTrick.leadSuit, state.trumpSuit);
      state.players[winnerIdx].tricksWonThisHand += 1;
      state.lastTrickWinnerIndex = winnerIdx;

      // record the completed trick (array of plays) into the winner's wonTricks for visualization
      const trickRecord = state.currentTrick.plays.map(p => ({ playerIndex: p.playerIndex, card: p.card }));
      state.players[winnerIdx].wonTricks = state.players[winnerIdx].wonTricks || [];
      state.players[winnerIdx].wonTricks.push(trickRecord);

      // store the completed trick on the table so it remains visible until the next lead
      state.lastCompletedTrick = trickRecord;

      // add played cards to log
      for(const pl of state.currentTrick.plays) state.playedCards.push(pl.card);

      // next leader is trick winner
      state.leaderIndex = winnerIdx;

      // next trick or end hand
      if(state.trickNumber >= 5){
        endHand();
        return;
      } else {
        state.trickNumber += 1;
        state.currentTrick = { plays: [], leadSuit: null };
        state.currentTurnIndex = firstActiveIndex(state.leaderIndex);
        setLock(true, state.currentTurnIndex);
        render();
        syncIfMulti();
        return;
      }
    }

    // otherwise next player's turn
    const nextIdx = getNextActiveIndex(state.currentTurnIndex);
    if(nextIdx !== null) state.currentTurnIndex = nextIdx;
    setLock(true, state.currentTurnIndex);
    render();
    syncIfMulti();
  };

  if(node){
    const rect = node.getBoundingClientRect();
    const target = els.trickArea.getBoundingClientRect();
    const clone = node.cloneNode(true);
    clone.classList.add('playClone');
    clone.style.width = rect.width + 'px';
    clone.style.height = rect.height + 'px';
    clone.style.left = rect.left + 'px';
    clone.style.top = rect.top + 'px';
    clone.style.margin = '0';
    clone.style.transform = 'translate(0,0) scale(1)';
    document.body.appendChild(clone);

    // compute center target (center of trickArea)
    const dx = (target.left + target.width/2) - (rect.left + rect.width/2);
    const dy = (target.top + target.height/2) - (rect.top + rect.height/2);

    requestAnimationFrame(()=>{
      clone.style.transform = `translate(${dx}px, ${dy}px) scale(0.92)`;
      clone.style.opacity = '0.98';
    });

    // wait for animation to complete
    setTimeout(()=>{
      clone.remove();
      commitPlay();
    }, 460);
    return;
  } else {
    // no DOM node found - fall back to instant commit
    commitPlay();
    return;
  }

  // if trick complete:
  if(state.currentTrick.plays.length === activePlayersCount()){
    const winnerIdx = determineTrickWinner(state.currentTrick.plays, state.currentTrick.leadSuit, state.trumpSuit);
    state.players[winnerIdx].tricksWonThisHand += 1;
    state.lastTrickWinnerIndex = winnerIdx;

    // record the completed trick (array of plays) into the winner's wonTricks for visualization
    const trickRecord = state.currentTrick.plays.map(p => ({ playerIndex: p.playerIndex, card: p.card }));
    state.players[winnerIdx].wonTricks = state.players[winnerIdx].wonTricks || [];
    state.players[winnerIdx].wonTricks.push(trickRecord);

    // store the completed trick on the table so it remains visible until the next lead
    state.lastCompletedTrick = trickRecord;

    // add played cards to log
    for(const pl of state.currentTrick.plays) state.playedCards.push(pl.card);

    // next leader is trick winner
    state.leaderIndex = winnerIdx;

    // next trick or end hand
    if(state.trickNumber >= 5){
      endHand();
      return;
    } else {
      state.trickNumber += 1;
      state.currentTrick = { plays: [], leadSuit: null };
      state.currentTurnIndex = firstActiveIndex(state.leaderIndex);
      setLock(true, state.currentTurnIndex);
      render();
      return;
    }
  }

  // otherwise next player's turn
  const nextIdx = getNextActiveIndex(state.currentTurnIndex);
  if(nextIdx !== null) state.currentTurnIndex = nextIdx;
  setLock(true, state.currentTurnIndex);
  render();
}

function endHand(){
  state.phase = PHASE.HAND_END;

  // scoring: count down from STARTING_SCORE, reset on DUNG
  for(const p of state.players){
    if(p.tricksWonThisHand === 0 && !p.folded){
      p.score = state.settings.startingScore;
      p.dingCount = (p.dingCount || 0) + 1;
    } else {
      p.score = Math.max(0, p.score - p.tricksWonThisHand);
    }
  }
  const winnerIdx = state.players.findIndex(p => p.score <= 0);
  state.winnerIndex = winnerIdx >= 0 ? winnerIdx : null;
  if(isMultiplayer()){
    const scores = state.players.map(p => ({ name: p.name, score: p.score }));
    logRoomEvent({ type: "hand_end", handId: state.handId, scores });
  }

  // dealer update
  if(DEALER_RULE === "LAST_TRICK_WINNER" && state.lastTrickWinnerIndex !== null){
    state.dealerIndex = state.lastTrickWinnerIndex;
  } else if(DEALER_RULE === "ROTATE"){
    state.dealerIndex = (state.dealerIndex + 1) % state.players.length;
  }

  // move trump to discard pile so it appears in logs (remove from any player's hand)
  if(state.trumpCard){
    for(const pl of state.players){
      if(!Array.isArray(pl.hand)) continue;
      const i = pl.hand.findIndex(c => c.id === state.trumpCard.id);
      if(i !== -1){ pl.hand.splice(i,1); break; }
    }
    state.discardPile.push(state.trumpCard);
    state.trumpCard = null;
    state.trumpSuit = null;
  }

  // reset turn pointers
  state.currentTurnIndex = state.dealerIndex;
  state.selectedCardIds.clear();
  state.selectedForSwap.clear();

  // auto lock to dealer (who will hit deal)
  setLock(true, state.dealerIndex);
  render();
  if(isMultiplayer()) syncRoomState("end-hand");
}

function renderScoreboard(){
  els.scoreboard.innerHTML = "";
  state.players.forEach((p, idx)=>{
    const row = document.createElement("div");
    row.className = "playerRow";
    // highlight active turn
    if(idx === state.currentTurnIndex) row.classList.add('activeTurn');
    const left = document.createElement("div");
    // show name, dealer badge, and turn indicator; keep folded badge if applicable
    left.innerHTML = `<div style="display:flex;align-items:center;gap:8px"><div style="display:flex;align-items:center;gap:8px"><div class="name">${p.name}</div>${idx===state.dealerIndex?'<span class="dealerBadge">Dealer</span>':''}${idx===state.currentTurnIndex?'<span class="turnDot">‚óè</span>':''}</div><span class="dingBadge">DING <strong class="mono">${p.dingCount || 0}</strong></span>${p.folded ? '<span class="foldedPill">Folded</span>' : ''}</div>`;
    // compact visualizer: five tiny card-chips + integrated trophy badge
    const visual = document.createElement('div');
    visual.className = 'trickVisualizer';
    const chips = document.createElement('div');
    chips.className = 'trickChipsRow';
    const MAX_TRICKS = 5;
    for(let i=0;i<MAX_TRICKS;i++){
      const chip = document.createElement('div');
      const isFilled = i < p.tricksWonThisHand;
      chip.className = 'trickChip ' + (isFilled ? 'filled' : 'empty');
      if(isFilled){
        const inner = document.createElement('div');
        inner.className = 'chipInner';
        // show small trophy glyph centered inside the gold mini-card
        inner.textContent = 'üèÜ';
        chip.appendChild(inner);
      }
      // highlight the most-recently-won chip for last trick winner
      if(i === p.tricksWonThisHand - 1 && state.lastTrickWinnerIndex === idx){
        chip.classList.add('recent');
      }
      chip.title = `${i+1} of ${MAX_TRICKS}`;
      chips.appendChild(chip);
    }

    // integrated trophy badge showing total tricks won for the hand
    const badge = document.createElement('div');
    badge.className = 'scoreTrophy';
    badge.innerHTML = `<span>üèÖ</span> <strong class="mono">${p.tricksWonThisHand}</strong>`;

    visual.appendChild(chips);
    visual.appendChild(badge);
    left.appendChild(visual);
    const right = document.createElement("div");
    // total score pill: bold, gold
    right.className = "totalScore";
    right.innerHTML = `<div class="scoreLabel">Score</div><strong class="mono scoreValue">${p.score}</strong>`;
    row.appendChild(left);
    row.appendChild(right);
    els.scoreboard.appendChild(row);
  });
}

function renderTrickArea(){
  els.trickArea.innerHTML = "";
  // show folded players on the table
  const folded = state.players.filter(p => p.folded).map(p => p.name);
  if(folded.length){
    const f = document.createElement('div');
    f.className = 'pill foldedPill';
    f.style.marginBottom = '8px';
    f.innerHTML = `<strong style="margin-right:8px;color:var(--muted);font-size:13px">Folded:</strong> <span style="color:var(--muted);">${folded.join(', ')}</span>`;
    els.trickArea.appendChild(f);
  }
  // show current trick plays
  if(state.phase === PHASE.LOBBY){
    els.trickArea.innerHTML = `<div class="small">Start a game, deal a hand, then play.</div>`;
    return;
  }

  const plays = state.currentTrick.plays;
  if(state.phase === PHASE.TRICK || state.phase === PHASE.HAND_END){
    const renderPlays = plays.length ? plays : (state.lastCompletedTrick || []);
    if(renderPlays.length === 0){
      const d = document.createElement("div");
      d.className = "small";
      d.textContent = "No cards played yet for this trick.";
      els.trickArea.appendChild(d);
    } else {
      for(const pl of renderPlays){
        const p = state.players[pl.playerIndex];
        const slot = document.createElement("div");
        slot.className = "trickSlot";

        const c = pl.card;
        const face = document.createElement("div");
        face.className = "cardFace " + (isRedSuit(c.suit) ? "red":"");
        // entry animation for recently played card
        if(state.lastPlayedCardId && c.id === state.lastPlayedCardId){
          face.classList.add('enter');
        }
        face.innerHTML = `<div class="top">${RANK_LABEL[c.rank] ?? c.rank}${SUIT_ICON[c.suit]}</div>
                          <div class="mid">${SUIT_ICON[c.suit]}</div>
                          <div class="bot">${RANK_LABEL[c.rank] ?? c.rank}${SUIT_ICON[c.suit]}</div>`;

        const name = document.createElement("div");
        name.className = "small";
        name.style.textAlign = "center";
        name.style.marginTop = "6px";
        name.textContent = p.name;

        slot.appendChild(face);
        slot.appendChild(name);
        els.trickArea.appendChild(slot);
      }
    }
  }

  // Swap info moved to unified notifier

  // show the last trick winner after each completed trick (styled pill with mini-card)
  if(state.lastCompletedTrick && state.lastTrickWinnerIndex !== null){
    const summary = document.createElement("div");
    summary.className = "pill trick-winner";
    const winner = state.players[state.lastTrickWinnerIndex]?.name ?? "‚Äî";
    // find the winning play so we can show the winning card visually
    const winningPlay = state.lastCompletedTrick.find(p => p.playerIndex === state.lastTrickWinnerIndex);
    const cardText = winningPlay ? `${RANK_LABEL[winningPlay.card.rank] ?? winningPlay.card.rank}${SUIT_ICON[winningPlay.card.suit]}` : '';

    summary.innerHTML = `
      <div style="display:flex;align-items:center;gap:12px">
        <div class="miniCard winner">${cardText}</div>
        <div style="display:flex;flex-direction:column">
          <div class="label">Trick winner</div>
          <strong>${winner}</strong>
        </div>
      </div>
    `;
    els.trickArea.prepend(summary);
    // trigger a tasteful pop animation on insertion
    requestAnimationFrame(()=>{
      summary.classList.add('pop');
      setTimeout(()=> summary.classList.remove('pop'), 900);
    });
  }
}

function renderHand(){
  els.handArea.innerHTML = "";
  els.selectedCount.textContent = "0";
  els.confirmPlayBtn.style.display = "none";

  const isMulti = isMultiplayer();
  const selfIndex = isMulti ? state.selfIndex : state.currentTurnIndex;
  const selfPlayer = (selfIndex !== null && selfIndex !== undefined) ? state.players[selfIndex] : null;
  const isSelfTurn = !isMulti || (state.selfIndex === state.currentTurnIndex);

  if(state.phase === PHASE.LOBBY){
    els.handHint.textContent = isMulti ? "Join a room to see your hand." : "Start a hand to see cards.";
    return;
  }

  // if locked, hide hand
  if(!isMulti && state.lockOn){
    els.handHint.textContent = "Hand hidden. Tap Reveal on the lock screen.";
    return;
  }

  if(!selfPlayer){
    els.handHint.textContent = isMulti ? "Join a room to see your hand." : "Waiting for players.";
    return;
  }

  const currentName = state.players[state.currentTurnIndex]?.name ?? "Player";
  if(state.phase === PHASE.SWAP){
    els.handHint.textContent = isSelfTurn
      ? "Select 0‚Äì3 cards to discard, then confirm."
      : `Waiting for ${currentName} to swap.`;
  } else if(state.phase === PHASE.TRICK){
    els.handHint.textContent = isSelfTurn
      ? "Select 1 card to play, then confirm."
      : `Waiting for ${currentName} to play.`;
  } else {
    els.handHint.textContent = "Hand ended ‚Äî deal next hand.";
  }
  // ensure hand visual is shown in player-held order (do not sort)
  const handForRender = isMulti ? (state.selfHand || []).slice() : (selfPlayer.hand || []).slice();

  const playable = (state.phase === PHASE.TRICK && isSelfTurn) ? playableCardIdsForCurrentPlayer() : null;
  const hyper = state.settings.hyperrealistic;
  const actionAllowed = !isMulti || isSelfTurn;

  handForRender.forEach(card=>{
      const btn = document.createElement("div");
      btn.className = "cardBtn " + (isRedSuit(card.suit) ? "red":"");
      btn.dataset.cardId = card.id;
      // highlight trumps in-hand with a subtle gold outline (disabled in hyperrealistic)
      if(!hyper && state.trumpSuit && card.suit === state.trumpSuit){ btn.classList.add('trump'); }
      // animate incoming cards
      if(state.incomingCardIds.has(card.id)){
        btn.classList.add('fly-in');
      }

      const top = `${RANK_LABEL[card.rank] ?? card.rank}${SUIT_ICON[card.suit]}`;
      btn.innerHTML = `<div class="top">${top}</div>
                       <div class="mid">${SUIT_ICON[card.suit]}</div>
                       <div class="bot">${top}</div>`;

      const isDisabled =
        !actionAllowed ||
        (!hyper && state.phase === PHASE.TRICK && playable && !playable.has(card.id)) ||
        (state.phase === PHASE.HAND_END);

      if(isDisabled) btn.classList.add("disabled");

      btn.addEventListener("click", ()=>{
        setError(null);
        if(!actionAllowed) return;
        if(state.phase === PHASE.HAND_END) return;
        if(state.phase === PHASE.SWAP){
          // prevent selecting after the player already swapped
          if(selfPlayer && selfPlayer.hasSwapped){ setError("You have already swapped this hand."); return; }
          if(isDisabled) return;
          if(state.selectedForSwap.has(card.id)){
            state.selectedForSwap.delete(card.id);
            btn.classList.remove("selected");
          } else {
            if(state.selectedForSwap.size >= 3){
              setError("Max 3 cards for swap.");
              return;
            }
            state.selectedForSwap.add(card.id);
            btn.classList.add("selected");
          }
          els.selectedCount.textContent = String(state.selectedForSwap.size);
          // visibility/label handled centrally in render()
          return;
        }

        if(state.phase === PHASE.TRICK){
          if(isDisabled) return;
          // single select
          state.selectedCardIds.clear();
          // clear UI selections
          els.handArea.querySelectorAll(".cardBtn.selected").forEach(x=>x.classList.remove("selected"));
          state.selectedCardIds.add(card.id);
          btn.classList.add("selected");
          els.selectedCount.textContent = "1";
          els.confirmPlayBtn.style.display = "inline-block";
        }
      });

      // pre-mark selected for swap
      if(state.phase === PHASE.SWAP && state.selectedForSwap.has(card.id)){
        btn.classList.add("selected");
      }
      if(state.phase === PHASE.TRICK && state.selectedCardIds.has(card.id)){
        btn.classList.add("selected");
      }

      els.handArea.appendChild(btn);
    });

  if(state.phase === PHASE.SWAP){
    els.selectedCount.textContent = actionAllowed ? String(state.selectedForSwap.size) : "0";
    // visibility and label are managed centrally in render(); here only ensure the button isn't disabled incorrectly
    if(actionAllowed && selfPlayer && !selfPlayer.hasSwapped){
      els.confirmSwapBtn.disabled = false; // allow 0-card keep
    }
  }
  if(state.phase === PHASE.TRICK){
    els.selectedCount.textContent = actionAllowed ? String(state.selectedCardIds.size) : "0";
    if(actionAllowed){
      els.confirmPlayBtn.style.display = "inline-block";
    }
  }

  // update auto-pass visual in hand header
  if(els.autoPassViz){
    if(isMulti){
      els.autoPassViz.style.display = 'none';
      if(els.passBtn) els.passBtn.style.display = 'none';
      return;
    }
    if(state.autoPassCountdown && state.phase === PHASE.SWAP){
      els.autoPassViz.style.display = 'flex';
      els.autoPassRing.textContent = String(state.autoPassCountdown);
      els.autoPassLabel.style.display = 'block';
      if(els.passBtn) els.passBtn.style.display = 'inline-block';
    } else {
      els.autoPassViz.style.display = 'none';
      if(els.passBtn) els.passBtn.style.display = 'none';
    }
  }
}

function renderHeaderPills(){
  els.phasePill.textContent = state.phase;
  if(state.trumpSuit){
    els.trumpPill.textContent = `${SUIT_ICON[state.trumpSuit]} (${cardLabel(state.trumpCard)})`;
    if(isRedSuit(state.trumpSuit)) els.trumpPill.classList.add('red'); else els.trumpPill.classList.remove('red');
  } else {
    els.trumpPill.textContent = "‚Äî";
    els.trumpPill.classList.remove('red');
  }
  els.leadPill.textContent = state.currentTrick.leadSuit ? SUIT_ICON[state.currentTrick.leadSuit] : "‚Äî";
  if(state.currentTrick.leadSuit){ if(isRedSuit(state.currentTrick.leadSuit)) els.leadPill.classList.add('red'); else els.leadPill.classList.remove('red'); } else { els.leadPill.classList.remove('red'); }
} 

function renderMeta(){
  if(state.players.length){
    els.turnName.textContent = state.players[state.currentTurnIndex]?.name ?? "‚Äî";
    els.dealerName.textContent = state.players[state.dealerIndex]?.name ?? "‚Äî";
  } else {
    els.turnName.textContent = "‚Äî";
    els.dealerName.textContent = "‚Äî";
  }
  els.trickNum.textContent = state.phase === PHASE.TRICK ? String(state.trickNumber) : (state.phase === PHASE.SWAP ? "‚Äî" : "‚Äî");
  // deck count is shown in the deck visualizer; keep header pill clean
  els.deckText.textContent = "";
}

function renderStatus(){
  let msg = "‚Äî";
  const isMulti = isMultiplayer();
  const winnerBanner = document.getElementById('winnerBanner');
  const winnerDetail = document.getElementById('winnerDetail');
  if(winnerBanner){
    if(state.winnerIndex !== null && state.players[state.winnerIndex]){
      winnerBanner.style.display = 'flex';
      const winnerName = state.players[state.winnerIndex].name;
      winnerDetail.textContent = `${winnerName} hit 0 and wins the game.`;
    } else {
      winnerBanner.style.display = 'none';
    }
  }
  // If notifier exists, populate it with richer UI; otherwise fall back to statusText
  const notifier = document.getElementById('notifier');
  const title = document.getElementById('notifierTitle');
  const detail = document.getElementById('notifierDetail');
  const icon = document.getElementById('notifierIcon');
  const playerBadge = document.getElementById('notifierPlayer');
  const actionBtn = document.getElementById('notifierAction');
  if(document.body) document.body.classList.remove('notifier-on');

  if(!notifier){
    // legacy fallback
    if(state.autoPassCountdown && state.autoPassCountdown > 0 && state.phase === PHASE.SWAP){
      msg = `Auto-passing in ${state.autoPassCountdown}s ‚Äî ${state.players[state.currentTurnIndex]?.name}`;
      els.statusText.textContent = msg;
      return;
    }
    if(state.phase === PHASE.LOBBY) msg = isMulti ? "Sign in and join a room to start." : "Enter names and start the game.";
    if(state.phase === PHASE.SWAP) msg = `Swap turn: ${state.players[state.currentTurnIndex].name}`;
    if(state.phase === PHASE.TRICK) {
      const lead = state.currentTrick.leadSuit ? ` | Lead: ${SUIT_ICON[state.currentTrick.leadSuit]}` : "";
      msg = `Play a card: ${state.players[state.currentTurnIndex].name}${lead}`;
    }
    if(state.phase === PHASE.HAND_END) msg = `Hand over. Dealer is ${state.players[state.dealerIndex].name}. Deal next hand when ready.`;
    els.statusText.textContent = msg;
    return;
  }

  // show notifier
  notifier.style.display = 'flex';
  if(document.body) document.body.classList.add('notifier-on');
  title.textContent = '';
  detail.textContent = '';
  playerBadge.style.display = 'none';
  actionBtn.style.display = 'none';

  if(state.phase === PHASE.LOBBY){
    icon.textContent = '‚ô†';
    title.textContent = 'Waiting to start';
    detail.textContent = isMulti ? 'Sign in and join a room to start.' : 'Enter 2‚Äì6 player names and start the game.';
  }

  if(state.phase === PHASE.SWAP){
    const name = state.players[state.currentTurnIndex]?.name ?? 'Player';
    icon.textContent = 'üîÅ';
    title.textContent = `Swap ‚Äî ${name}`;
    detail.textContent = `${name} may discard 0‚Äì3 cards, then draw.`;
    playerBadge.style.display = 'inline-flex'; playerBadge.textContent = name;
    if(state.autoPassCountdown && state.autoPassCountdown > 0){ detail.textContent += ` ‚Äî Auto-pass in ${state.autoPassCountdown}s`; }
  }

  if(state.phase === PHASE.TRICK){
    const name = state.players[state.currentTurnIndex]?.name ?? 'Player';
    icon.textContent = '‚ñ∂Ô∏è';
    const lead = state.currentTrick.leadSuit ? `${SUIT_ICON[state.currentTrick.leadSuit]}` : '‚Äî';
    title.textContent = `Play ‚Äî ${name}`;
    detail.textContent = `Lead: ${lead} ¬∑ Select 1 card to play.`;
    playerBadge.style.display = 'inline-flex'; playerBadge.textContent = name;
  }

  if(state.phase === PHASE.HAND_END){
    icon.textContent = 'üèÅ';
    title.textContent = 'Hand complete';
    detail.textContent = `Dealer: ${state.players[state.dealerIndex]?.name ?? '‚Äî'}. Deal next hand when ready.`;
    // notifications are informational only; actions are handled in the main UI
  }

  // keep legacy status text for compact header summary
  els.statusText.textContent = detail.textContent || '‚Äî';
}

// deck visualizer removed

function render(){
  if(state.phase !== PHASE.LOBBY && state.lastPhase === PHASE.LOBBY){
    state.settingsCollapsed = true;
  }
  renderHeaderPills();
  renderMeta();
  const isMulti = isMultiplayer();
  const isSelfTurn = !isMulti || state.selfIndex === state.currentTurnIndex;
  const isHost = !isMulti || (state.selfUid && state.hostUid && state.selfUid === state.hostUid);
  const isSelfDealer = !isMulti || (state.selfIndex !== null && state.selfIndex === state.dealerIndex);

  // apply collapsed classes & update collapse button icons
  if(els.gamePanel) els.gamePanel.classList.toggle('collapsed', !!state.collapsed.game);
  if(els.tablePanel) els.tablePanel.classList.toggle('collapsed', !!state.collapsed.table);
  // ensure hand panel defaults to open
  state.collapsed.hand = !!state.collapsed.hand;
  if(els.handPanel) els.handPanel.classList.toggle('collapsed', !!state.collapsed.hand);
  if(els.logCard) els.logCard.classList.toggle('collapsed', !!state.logCollapsed);
  if(els.collapseGameBtn) els.collapseGameBtn.textContent = state.collapsed.game ? '‚ñ∏' : '‚ñæ';
  if(els.collapseTableBtn) els.collapseTableBtn.textContent = state.collapsed.table ? '‚ñ∏' : '‚ñæ';
  if(els.collapseHandBtn) els.collapseHandBtn.textContent = state.collapsed.hand ? '‚ñ∏' : '‚ñæ';

  // update left carets and aria-expanded attributes
  if(els.gameCaret){ els.gameCaret.classList.toggle('collapsed', !!state.collapsed.game); }
  if(els.tableCaret){ els.tableCaret.classList.toggle('collapsed', !!state.collapsed.table); }
  if(els.handCaret){ els.handCaret.classList.toggle('collapsed', !!state.collapsed.hand); }
  if(els.gameHeader){ els.gameHeader.setAttribute('aria-expanded', String(!state.collapsed.game)); }
  if(els.tableHeader){ els.tableHeader.setAttribute('aria-expanded', String(!state.collapsed.table)); }
  if(els.handHeader){ els.handHeader.setAttribute('aria-expanded', String(!state.collapsed.hand)); }
  if(els.logHeader){ els.logHeader.setAttribute('aria-expanded', String(!state.logCollapsed)); }

  // remove rough subtitles from headers (keep headers minimal)
  if(els.gameSummary){ els.gameSummary.textContent = ''; }
  if(els.tableSummary){ els.tableSummary.textContent = ''; }
  if(els.handSummary){ els.handSummary.textContent = ''; }

  if(state.phase === PHASE.LOBBY){
    els.lobbyArea.style.display = "flex";
    els.controlsArea.style.display = "none";
    if(els.startGameBtn){
      els.startGameBtn.disabled = isMulti ? (!isHost || state.players.length < 2) : false;
    }
    renderLobbyPlayers();
  } else {
    els.lobbyArea.style.display = "none";
    els.controlsArea.style.display = "flex";
    renderScoreboard();
    // disable deal button while a hand is in progress
    els.startHandBtn.disabled = (state.phase !== PHASE.HAND_END) || (state.players.length < 2) || !isSelfDealer;
    // hide Deal Hands unless it's time to deal
    if(els.startHandBtn){ els.startHandBtn.style.display = (state.phase === PHASE.HAND_END && state.players.length >= 2 && isSelfDealer) ? 'inline-block' : 'none'; }
  }
  if(els.tablePanel){
    els.tablePanel.style.display = (state.phase === PHASE.LOBBY) ? "none" : "block";
  }

  // settings: lock after lobby, but allow peek by expanding
  const settingsLocked = state.phase !== PHASE.LOBBY || (isMulti && !isHost);
  if(els.settingsCard){
    els.settingsCard.classList.toggle('collapsed', !!state.settingsCollapsed);
  }
  if(els.settingsCaret){
    els.settingsCaret.classList.toggle('collapsed', !!state.settingsCollapsed);
  }
  if(els.settingsLockPill){
    els.settingsLockPill.style.display = settingsLocked ? 'inline-flex' : 'none';
  }
  const setDisabled = (el, disabled)=>{ if(el) el.disabled = disabled; };
  setDisabled(els.startingScoreInput, settingsLocked);
  setDisabled(els.foldThresholdInput, settingsLocked);
  setDisabled(els.deckCountInput, settingsLocked);
  setDisabled(els.hyperrealisticInput, settingsLocked);

  // Confirm-swap button: disable once the current player has already confirmed swap (or if not in SWAP)
  if(els.confirmSwapBtn){
    const cur = state.players[state.currentTurnIndex];
    const canSwap = !!(state.phase === PHASE.SWAP && cur && !cur.folded && !cur.hasSwapped && !state.dealing);
    const showSwap = canSwap && (!isMulti || isSelfTurn);
    els.confirmSwapBtn.disabled = !showSwap;
    // hide confirm swap unless actually in swap and current player can swap
    els.confirmSwapBtn.style.display = showSwap ? 'inline-block' : 'none';
    // update label based on number of selected cards when visible
    if(showSwap){
      // simple confirm button ‚Äî always use 'Confirm'
      els.confirmSwapBtn.textContent = 'Confirm';
    }
  }

  // Fold button: show during SWAP unless already folded; if the player has already swapped, keep it visible but disabled (greyed out)
  if(els.foldBtn){
    const cur = state.players[state.currentTurnIndex];
    const canFold = !!(state.phase === PHASE.SWAP && cur && !cur.folded && state.currentTurnIndex !== state.dealerIndex);
    const showFold = canFold && (!isMulti || isSelfTurn);
    els.foldBtn.style.display = showFold ? 'inline-block' : 'none';
    els.foldBtn.disabled = !showFold || !!(cur && cur.hasSwapped);
  }

  // Pass device button removed; auto-pass handles progression.

  renderTrickArea();
  renderHand();
  renderStatus();
  renderRoomLog();
  state.lastPhase = state.phase;

  // keep Game header summary empty; notifier handles status now
  if(els.gameSummary){ els.gameSummary.textContent = ''; }
}

els.startGameBtn.addEventListener("click", ()=>{
  setError(null);
  if(isMultiplayer()){
    startMultiplayerGame();
    return;
  }
  const names = els.namesInput.value
    .split("\n")
    .map(s=>s.trim())
    .filter(Boolean);

  if(names.length < 2 || names.length > 6){
    setError("Enter 2‚Äì6 player names (one per line).");
    return;
  }
  initPlayers(names);
  state.phase = PHASE.SWAP; // we'll immediately wait for deal
  state.phase = PHASE.HAND_END; // show controls and let dealer deal
  state.dealerIndex = 0;
  state.currentTurnIndex = 0;
  state.winnerIndex = null;
  state.settingsCollapsed = true;
  setLock(true, 0);
  render();
});

els.startHandBtn.addEventListener("click", ()=>{
  if(state.players.length < 2) return;
  if(state.phase !== PHASE.HAND_END){ setError("Can't deal: finish the current hand first."); return; }
  dealHand();
});

els.confirmSwapBtn.addEventListener("click", ()=>{
  if(state.lockOn){ setError("Reveal first."); return; }
  confirmSwap();
});

els.confirmPlayBtn.addEventListener("click", ()=>{
  if(state.lockOn){ setError("Reveal first."); return; }
  playSelectedCard();
});

if(els.passBtn){
  els.passBtn.addEventListener("click", ()=>{
    if(state.phase !== PHASE.SWAP) return;
    if(state.autoPassTimer){ clearInterval(state.autoPassTimer); state.autoPassTimer = null; }
    state.autoPassCountdown = null;
    advanceSwapTurn();
    render();
  });
}

// Pass button removed ‚Äî auto-pass handles swap progression.

els.resetBtn.addEventListener("click", ()=>{
  if(isMultiplayer()){
    resetRoomState();
    return;
  }
  resetAll();
});

els.revealBtn.addEventListener("click", ()=>{
  // if there's a pending reveal for a locked player, animate their initial cards
  if(state.lockOn && state.pendingRevealForIndex !== null && state.phase === PHASE.SWAP){
    const idx = state.pendingRevealForIndex;
    // only perform initial fly-in if this player hasn't had their initial reveal yet
    if(state.playersPendingInitial.has(idx)){
      // mark incoming for this player's current hand
      state.players[idx].hand.forEach(c => state.incomingCardIds.add(c.id));
      // remove pending flag
      state.playersPendingInitial.delete(idx);
      // unlock so they can interact
      setLock(false, null);
      render();
      // clear incoming flags after animation duration
      setTimeout(()=>{
        state.players[idx].hand.forEach(c => state.incomingCardIds.delete(c.id));
        render();
      }, 650);
      return;
    }
  }

  // default reveal behavior
  setLock(false, null);
  render();
});
if(els.settingsHeader){
  const toggleSettings = ()=>{
    state.settingsCollapsed = !state.settingsCollapsed;
    render();
  };
  els.settingsHeader.addEventListener("click", (e)=>{
    e.preventDefault();
    toggleSettings();
  });
  els.settingsHeader.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){
      e.preventDefault();
      toggleSettings();
    }
  });
}
if(els.logHeader){
  const toggleLog = ()=>{
    state.logCollapsed = !state.logCollapsed;
    render();
    if(!state.logCollapsed) requestAnimationFrame(()=> scrollLogToBottom());
  };
  els.logHeader.addEventListener("click", (e)=>{
    e.preventDefault();
    toggleLog();
  });
  els.logHeader.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){
      e.preventDefault();
      toggleLog();
    }
  });
}
if(els.startingScoreInput){
  els.startingScoreInput.addEventListener("input", ()=>{
    state.settings.startingScore = Number(els.startingScoreInput.value);
    clampSettings();
    if(state.settings.foldThreshold > state.settings.startingScore){
      state.settings.foldThreshold = state.settings.startingScore;
    }
    syncSettingsUI();
  });
}
if(els.foldThresholdInput){
  els.foldThresholdInput.addEventListener("input", ()=>{
    state.settings.foldThreshold = Number(els.foldThresholdInput.value);
    clampSettings();
    syncSettingsUI();
  });
}
if(els.deckCountInput){
  els.deckCountInput.addEventListener("input", ()=>{
    state.settings.decks = Number(els.deckCountInput.value);
    clampSettings();
    syncSettingsUI();
  });
}
if(els.hyperrealisticInput){
  els.hyperrealisticInput.addEventListener("change", ()=>{
    state.settings.hyperrealistic = !!els.hyperrealisticInput.checked;
    syncSettingsUI();
    render();
  });
}

if(els.modeHotseatBtn){
  els.modeHotseatBtn.addEventListener("click", ()=> setMode(MODE.HOTSEAT));
}
if(els.modeMultiBtn){
  els.modeMultiBtn.addEventListener("click", ()=> setMode(MODE.MULTI));
}
if(els.roomCodeInput){
  els.roomCodeInput.addEventListener("input", ()=>{
    els.roomCodeInput.value = normalizeRoomCode(els.roomCodeInput.value);
  });
  els.roomCodeInput.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      joinRoom();
    }
  });
}
if(els.createRoomBtn){
  els.createRoomBtn.addEventListener("click", ()=> createRoom());
}
if(els.joinRoomBtn){
  els.joinRoomBtn.addEventListener("click", ()=> joinRoom());
}
if(els.shareRoomBtn){
  els.shareRoomBtn.addEventListener("click", ()=> shareRoomCode());
}
if(els.signInBtn){
  els.signInBtn.addEventListener("click", async ()=>{
    if(!firebaseAuth || !googleProvider){
      setError("Firebase not configured.");
      return;
    }
    try{
      await signInWithPopup(firebaseAuth, googleProvider);
    } catch (err){
      if(err && err.code === "auth/popup-blocked"){
        await signInWithRedirect(firebaseAuth, googleProvider);
        return;
      }
      console.error("Sign-in failed:", err);
      setError("Sign-in failed.");
    }
  });
}
if(els.signOutBtn){
  els.signOutBtn.addEventListener("click", async ()=>{
    if(!firebaseAuth) return;
    try{
      await signOut(firebaseAuth);
    } finally {
      leaveRoom();
      updateAuthUI();
    }
  });
}

if(firebaseAuth){
  onAuthStateChanged(firebaseAuth, async (user)=>{
    state.isSignedIn = !!user;
    state.selfUid = user ? user.uid : null;
    state.selfName = user ? (user.displayName || (user.email ? user.email.split("@")[0] : "Player")) : null;
    updateAuthUI();
    if(!user){
      leaveRoom();
      return;
    }
    if(state.mode === MODE.MULTI){
      await maybeAutoJoinRoom();
    }
  });
}

resetAll();
updateModeUI();
updateAuthUI();
updateRoomStatus();
</script>
</body>
</html>
